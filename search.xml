<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java中的反射机制</title>
    <url>/2020/08/07/Java%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="1-什么是反射"><a href="#1-什么是反射" class="headerlink" title="##1. 什么是反射"></a>##1. 什么是反射</h2><p><strong><em>Java的反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制。反射被视为动态语言的关键。</em></strong></p>
<p><em>[以上来源于百度百科]</em></p>
<a id="more"></a>
<p>我们平常编程时，可能会用到各种各样的框架，如学校教学使用的SWT、Swing框架，或者是企业开发使用的Spring框架等，这些都或多或少地给我们编程带来了便利。</p>
<p><strong>框架：是一种半成品软件，使用者可以在框架的基础上进行软件开发，直接使用框架中已经封装好的方法，可以简化编码过程。</strong></p>
<p>开发者开发框架时，经常用到反射机制。</p>
<p><strong>反射：将类的各个组成部分封装为其他对象。</strong></p>
<p><strong>对于框架的开发者来说，反射机制就是框架设计的灵魂。</strong></p>
<hr>
<h2 id="2-一个类从编写到运行经历的过程"><a href="#2-一个类从编写到运行经历的过程" class="headerlink" title="##2. 一个类从编写到运行经历的过程"></a>##2. 一个类从编写到运行经历的过程</h2><p>我们编写一个类Person，</p>
<img src="/2020/08/07/Java%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/1.jpg" class title="Person类">
<p>然后我们就可以在main函数中对这个类进行实例化，并调用里面的方法了，</p>
<img src="/2020/08/07/Java%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/2.jpg" class title="实例化对象">
<p>那么这是怎么做到的呢？</p>
<p><strong>2.1. 源代码阶段</strong><br>写完一个类的代码后，在没有错误的情况下，进行编译，会生成对应的.class文件，<strong>（.java -&gt; .class）</strong>，那么这里的.class，也就是字节码文件，他存放的是什么呢？<br>显然就是这个类的一些信息，包括这个类的<strong>类名、成员变量、构造方法、成员方法等</strong>。</p>
<p>此时，.java文件和.class文件都是静态存放在硬盘上的。</p>
<img src="/2020/08/07/Java%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/3.jpg" class title="源代码阶段">

<hr>
<p><strong>2.2. Class类对象阶段</strong><br>在Java中，有一个<strong>Class类</strong>，用来<strong>描述字节码文件的信息</strong>，它其中有三个成员变量，用来存放对应的信息：</p>
<pre><code>成员变量数组 Field[] fields，用来存放字节码中代表成员变量的信息；
构造函数数组 Constructor[] cons，用来存放字节码中代表构造函数的信息；
成员方法数组 Method[] methods，用来存放字节码中代表成员方法的信息。</code></pre><p>在编译过程中，java会使用<strong>类加载器（ClassLoader）</strong>来将字节码中的信息，加载到一个Class类中，供后续操作使用。</p>
<img src="/2020/08/07/Java%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/4.jpg" class title="Class类对象阶段">

<p><strong>也就是说，此时，我们将类的各个组成部分封装成了不同的对象，这就是我们说的“反射”机制。</strong></p>
<hr>
<p><strong>2.3. 运行时阶段</strong><br>此时我们就可以<strong>通过这个Class类对象，来创建我们想要的Person对象了。</strong></p>
<img src="/2020/08/07/Java%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/2.jpg" class title="实例化对象">

<hr>
<h2 id="3-获取字节码Class对象的三种方式"><a href="#3-获取字节码Class对象的三种方式" class="headerlink" title="##3. 获取字节码Class对象的三种方式"></a>##3. 获取字节码Class对象的三种方式</h2><p><strong>3.1. Class.forName(“全类名”);</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class clazz1 &#x3D; Class.forName(&quot;packagename.Person&quot;);</span><br><span class="line">&#x2F;&#x2F;注意：一定要把 包名.类名 写全</span><br></pre></td></tr></table></figure>
<p><strong>3.2. 类名.class</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class clazz2 &#x3D; Person.class;</span><br></pre></td></tr></table></figure>
<p><strong>3.3. 对象名.getClass();</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person person &#x3D; new Person();&#x2F;&#x2F;需要先有对象</span><br><span class="line">Class clazz3 &#x3D; person.getClass();</span><br></pre></td></tr></table></figure>

<p><strong>重点：对于同一个类，用以上三种方法得出的Class对象，是同一个对象，也就是说，这三个Class对象本质是同一个东西。</strong></p>
<p>可以这么测试一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.println(clazz1 &#x3D;&#x3D; clazz2);&#x2F;&#x2F;输出true</span><br><span class="line">System.out.println(clazz1 &#x3D;&#x3D; clazz3);&#x2F;&#x2F;输出true</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-使用Class类对象-获取Field"><a href="#4-使用Class类对象-获取Field" class="headerlink" title="##4. 使用Class类对象_获取Field"></a>##4. 使用Class类对象_获取Field</h2><p><strong>①. Field[] getFields() throws SecurityException</strong></p>
<pre><code>获取类中所有以public修饰的成员变量</code></pre><p><strong>②. Field getField(String name) throws NoSuchFieldException, SecurityException</strong></p>
<pre><code>获取类中一个指定名称的且以public修饰的成员变量，
如没有找到指定名称的变量或该变量不以public修饰，则报错</code></pre><p><strong>③. Field[] getDeclaredFields() throws SecurityException</strong></p>
<pre><code>获取类中所有的成员变量</code></pre><p><strong>④. Field getDeclaredField(String name) throws NoSuchFieldException, SecurityException</strong></p>
<pre><code>获取类中一个指定名称的成员变量，
如没有找到指定名称的变量，则报错</code></pre><p><strong>对于得到的成员变量Field field，我们可以进行如下操作：</strong></p>
<p><strong>⑤. Object get(Object obj) throws IllegalArgumentException, IllegalAccessException</strong></p>
<pre><code>传入一个对象obj，获取该对象的成员变量中，与field一致的元素值</code></pre><p><strong>⑥. void set(Object obj, Object value) throws IllegalArgumentException, IllegalAccessException</strong></p>
<pre><code>传入一个对象obj和修改值value，将该对象中，成员变量为field的元素值修改为value，
如果该成员变量不为public修饰，则会报错</code></pre><p><strong>⑦. void AccessibleObject.setAccessible(boolean flag) throws SecurityException</strong></p>
<pre><code>强制反射，
针对上一条函数，在调用⑥前加上该函数，且传入变量true，则允许对任意修饰的元素值进行修改</code></pre><hr>
<p><strong>测试代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">	private String name;</span><br><span class="line">	private int age;</span><br><span class="line">	public String sex;</span><br><span class="line">	public int height;</span><br><span class="line">	</span><br><span class="line">	public Person() &#123;</span><br><span class="line">		this.name &#x3D; &quot;zhangsan&quot;;</span><br><span class="line">		this.age &#x3D; 10;</span><br><span class="line">		this.sex &#x3D; &quot;man&quot;;</span><br><span class="line">		this.height &#x3D; 178;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public int getAge() &#123;</span><br><span class="line">		return this.age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TestReflectDemo1 &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		&#x2F;&#x2F;0. 获取Person的Class对象</span><br><span class="line">		Class clazz &#x3D; Person.class;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;1. Field[ ] getFields()获取所有public修饰的成员变量</span><br><span class="line">		Field[] fields &#x3D; clazz.getFields();</span><br><span class="line">		for(Field field : fields) &#123;</span><br><span class="line">			System.out.println(field);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;------------------------------------------------------------------------------&quot;);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;2. Field getField(String name)获取指定名称的public修饰的成员变量</span><br><span class="line">		Field field1 &#x3D; clazz.getField(&quot;sex&quot;);</span><br><span class="line">		System.out.println(field1);</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;------------------------------------------------------------------------------&quot;);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;3. Field[ ] getDeclaredFields() 获取所有成员变量</span><br><span class="line">		Field[] fields2 &#x3D; clazz.getDeclaredFields();</span><br><span class="line">		for(Field field : fields2) &#123;</span><br><span class="line">			System.out.println(field);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;------------------------------------------------------------------------------&quot;);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;4. Field getField(String name)获取指定名称的成员变量</span><br><span class="line">		Field field2 &#x3D; clazz.getDeclaredField(&quot;age&quot;);</span><br><span class="line">		System.out.println(field2);</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;------------------------------------------------------------------------------&quot;);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;5. Object get(Object o)获取指定对象的指定元素值</span><br><span class="line">		Person person &#x3D; new Person();</span><br><span class="line">		Object value1 &#x3D; field1.get(person);</span><br><span class="line">		System.out.println(value1);&#x2F;&#x2F;输出：man</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;------------------------------------------------------------------------------&quot;);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;6. void set(Object o,Object value) 将指定对象的指定元素修改为另一个值</span><br><span class="line">		field2.setAccessible(true);&#x2F;&#x2F;强制反射</span><br><span class="line">		</span><br><span class="line">		System.out.println(person.getAge());&#x2F;&#x2F;输出：10</span><br><span class="line">		field2.set(person, 100);</span><br><span class="line">		System.out.println(person.getAge());&#x2F;&#x2F;输出：100</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;------------------------------------------------------------------------------&quot;);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果：</strong></p>
<img src="/2020/08/07/Java%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/5.jpg" class title="运行结果">

<hr>
<h2 id="5-使用Class类对象-获取Constructor"><a href="#5-使用Class类对象-获取Constructor" class="headerlink" title="##5. 使用Class类对象_获取Constructor"></a>##5. 使用Class类对象_获取Constructor</h2><p>与上一节类似，在此简单说明一下用法。</p>
<p><strong>①. Constructor<T> getConstructor(Class&lt;?&gt;… parameterTypes) throws NoSuchMethodException, SecurityException</T></strong></p>
<pre><code>传入若干个参数，获取类中参数数量与类型与传入参数一致的构造方法</code></pre><p><strong>②. T newInstance(Object… initargs) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException</strong></p>
<pre><code>使用构造方法创建一个新对象，传入参数要和构造方法一致</code></pre><hr>
<p><strong>测试代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">	private String name;</span><br><span class="line">	private int age;</span><br><span class="line">	</span><br><span class="line">	public Person(String name,int age) &#123;</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">		this.age &#x3D; age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		String ret &#x3D; &quot;姓名：&quot; + this.name + &quot; 年龄：&quot; + this.age;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TestReflectDemo1 &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		&#x2F;&#x2F;0. 获取Person的Class对象</span><br><span class="line">		Class&lt;Person&gt; clazz &#x3D; Person.class;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;1. 获取构造器</span><br><span class="line">		Constructor&lt;Person&gt; construct &#x3D; clazz.getConstructor(String.class,int.class);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;2. 使用构造器创建新对象</span><br><span class="line">		Object person &#x3D; construct.newInstance(&quot;张三&quot;,10);</span><br><span class="line">		System.out.println(person);</span><br><span class="line">		&#x2F;&#x2F;输出：姓名：张三 年龄：10</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-使用Class类对象-获取Method"><a href="#6-使用Class类对象-获取Method" class="headerlink" title="##6. 使用Class类对象_获取Method"></a>##6. 使用Class类对象_获取Method</h2><p>与上面的大同小异，简单说说一个用法：</p>
<p><strong>①. Method getMethod(String name, Class&lt;?&gt;… parameterTypes) throws NoSuchMethodException, SecurityException</strong></p>
<pre><code>由于获取类方法需要考虑方法重载的问题，所以获取方法时，不仅需要传入方法名，还需要传入方法所需参数类型</code></pre><p><strong>②. Object Method.invoke(Object obj, Object… args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException</strong></p>
<pre><code>执行方法，
需要传入执行的对象，和该方法所需的参数</code></pre><hr>
<p><strong>测试代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">	private String name;</span><br><span class="line">	private int age;</span><br><span class="line">	</span><br><span class="line">	public Person(String name,int age) &#123;</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">		this.age &#x3D; age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void print(int year) &#123;</span><br><span class="line">		System.out.println(name + &quot;现在&quot; + this.age + &quot;岁，&quot; + year + &quot;年后&quot; + (this.age+year) + &quot;岁&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TestReflectDemo1 &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		&#x2F;&#x2F;0. 获取Person的Class对象</span><br><span class="line">		Class&lt;Person&gt; clazz &#x3D; Person.class;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;1. 获取方法</span><br><span class="line">		Method method &#x3D; clazz.getMethod(&quot;print&quot;,int.class);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;2. 对一个对象调用方法</span><br><span class="line">		Person person &#x3D; new Person(&quot;张三&quot;,10);</span><br><span class="line">		method.invoke(person, 5);</span><br><span class="line">		&#x2F;&#x2F;输出：张三现在10岁，5年后15岁</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>获取类名：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class clazz &#x3D; Person.class;</span><br><span class="line">System.out.println(clazz.getName());</span><br><span class="line">&#x2F;&#x2F;输出：Person</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>Java知识点</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合-Collection[Java知识点]</title>
    <url>/2020/07/13/Java%E9%9B%86%E5%90%88-Collection-Java%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p><strong>Collection接口统一定义了一系列单列集合</strong></p>
<a id="more"></a>

<hr>
<h2 id="1-Collection集合的继承树"><a href="#1-Collection集合的继承树" class="headerlink" title="##1. Collection集合的继承树"></a>##1. Collection集合的继承树</h2><img src="/2020/07/13/Java%E9%9B%86%E5%90%88-Collection-Java%E7%9F%A5%E8%AF%86%E7%82%B9/1.jpg" class title="Collection集合的继承树">

<hr>
<h2 id="2-Collection的常用方法"><a href="#2-Collection的常用方法" class="headerlink" title="##2. Collection的常用方法"></a>##2. Collection的常用方法</h2><p><strong>boolean add(E e)</strong></p>
<pre><code>在集合中添加一个元素e
添加成功则返回true</code></pre><p><strong>boolean addAll(Collection&lt;? extends E&gt; c)</strong></p>
<pre><code>在集合中添加一组元素c
添加成功则返回true</code></pre><p><strong>boolean contains(Object o)</strong></p>
<pre><code>集合中是否存在元素o
存在则返回true，否则返回false</code></pre><p><strong>boolean isEmpty()</strong></p>
<pre><code>集合是否为空（没有元素）
为空则返回true，否则返回false</code></pre><p><strong>boolean remove(Object o)</strong></p>
<pre><code>删除集合中第一次出现值等于元素o的元素
删除成功则返回true</code></pre><p><strong>int size()</strong></p>
<pre><code>获得集合的大小
即集合中元素的个数</code></pre><p><strong><E> E[] toArray(E[] a)</E></strong></p>
<pre><code>将集合转换为数组
如将Integer类型的集合转换为Integer类型的数组</code></pre><p><strong>boolean retainAll(Collection&lt;?&gt; c)</strong></p>
<pre><code>保留原集合中，值等于给定集合c中出现过的值，删掉其他的</code></pre><p><strong>void clear()</strong></p>
<pre><code>清空集合元素</code></pre><hr>
<h2 id="3-测试代码"><a href="#3-测试代码" class="headerlink" title="##3. 测试代码"></a>##3. 测试代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collection;</span><br><span class="line"></span><br><span class="line">public class TestCollection &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Collection&lt;Integer&gt; coll&#x3D;new ArrayList&lt;Integer&gt;();</span><br><span class="line">		</span><br><span class="line">		coll.add(1);</span><br><span class="line">		coll.add(5);</span><br><span class="line">		coll.add(-5);</span><br><span class="line">		System.out.println(coll);&#x2F;&#x2F;添加元素</span><br><span class="line">		&#x2F;&#x2F;输出：[1, 5, -5]</span><br><span class="line">		</span><br><span class="line">		coll.addAll(coll);</span><br><span class="line">		System.out.println(coll);&#x2F;&#x2F;添加一组元素</span><br><span class="line">		&#x2F;&#x2F;输出：[1, 5, -5, 1, 5, -5]</span><br><span class="line">		</span><br><span class="line">		System.out.println(coll.contains(5));&#x2F;&#x2F;集合中是否存在元素</span><br><span class="line">		&#x2F;&#x2F;输出：true</span><br><span class="line">		</span><br><span class="line">		System.out.println(coll.isEmpty());&#x2F;&#x2F;集合是否为空</span><br><span class="line">		&#x2F;&#x2F;输出：false</span><br><span class="line">		</span><br><span class="line">		coll.remove(1);&#x2F;&#x2F;删除集合中第一次出现的该值，不存在则不删除</span><br><span class="line">		System.out.println(coll);</span><br><span class="line">		&#x2F;&#x2F;输出：[5, -5, 1, 5, -5]</span><br><span class="line"></span><br><span class="line">		System.out.println(coll.size());&#x2F;&#x2F;返回集合的大小，即元素的个数</span><br><span class="line">		&#x2F;&#x2F;输出：5</span><br><span class="line">		</span><br><span class="line">		Integer[] a&#x3D;coll.toArray(new Integer[coll.size()]);&#x2F;&#x2F;集合转数组</span><br><span class="line">		for(int k:a)</span><br><span class="line">			System.out.print(k+&quot; &quot;);</span><br><span class="line">		System.out.println();</span><br><span class="line">		&#x2F;&#x2F;输出：5 -5 1 5 -5 </span><br><span class="line">		</span><br><span class="line">		Collection&lt;Integer&gt; ls&#x3D;new ArrayList&lt;Integer&gt;();</span><br><span class="line">		ls.add(5);</span><br><span class="line">		ls.add(-5);</span><br><span class="line">		coll.retainAll(ls);&#x2F;&#x2F;集合中保留给定集合中的值，删掉其他值</span><br><span class="line">		System.out.println(coll);</span><br><span class="line">		&#x2F;&#x2F;输出：[5, -5, 5, -5]</span><br><span class="line">		</span><br><span class="line">		coll.clear();&#x2F;&#x2F;清空集合</span><br><span class="line">		System.out.println(coll);</span><br><span class="line">		&#x2F;&#x2F;输出：[]</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-相关链接"><a href="#4-相关链接" class="headerlink" title="##4. 相关链接"></a>##4. 相关链接</h2><p><a href="https://dulaogou.vip/2020/07/13/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">Java集合框架</a><br><a href="https://dulaogou.vip/2020/07/14/Java%E9%9B%86%E5%90%88-List%E5%92%8CArrayList-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">Java集合-List和ArrayList</a><br><a href="https://dulaogou.vip/2020/07/14/Java%E9%9B%86%E5%90%88-Queue%E5%92%8CLinkedList-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">Java集合-Queue和LinkedList</a><br><a href="https://dulaogou.vip/2020/07/16/Java%E9%9B%86%E5%90%88-Map%E5%92%8CHashMap-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">Java集合-Map和HashMap</a><br><a href="https://dulaogou.vip/2020/07/16/Java%E9%9B%86%E5%90%88-%E5%90%84%E7%A7%8D%E9%9B%86%E5%90%88%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">Java集合-各种集合的使用场景</a></p>
]]></content>
      <categories>
        <category>Java知识点</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Collection</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合-List和ArrayList[Java知识点]</title>
    <url>/2020/07/14/Java%E9%9B%86%E5%90%88-List%E5%92%8CArrayList-Java%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p><strong>Collection不支持下标操作，只提供了一些基本的集合操作，而List更像是数组，可以进行下标操作。</strong><br><strong>List是一个接口，而ArrayList是List的一个实现类</strong><br><strong>如果我们需要定义一个ArrayList变量，那以下两种方法都是可以的：</strong></p>
<pre><code>List&lt;E&gt; array=new ArrayList&lt;E&gt;();
ArrayList&lt;E&gt; array=new ArrayList&lt;E&gt;();</code></pre><a id="more"></a>

<hr>
<h2 id="1-Collection集合的继承树"><a href="#1-Collection集合的继承树" class="headerlink" title="##1. Collection集合的继承树"></a>##1. Collection集合的继承树</h2><img src="/2020/07/14/Java%E9%9B%86%E5%90%88-List%E5%92%8CArrayList-Java%E7%9F%A5%E8%AF%86%E7%82%B9/1.jpg" class title="Collection集合的继承树">

<hr>
<h2 id="2-List和ArrayList的常用方法"><a href="#2-List和ArrayList的常用方法" class="headerlink" title="##2. List和ArrayList的常用方法"></a>##2. List和ArrayList的常用方法</h2><p><strong>boolean add(E e)</strong></p>
<pre><code>在集合末尾增加一个元素e
添加成功则返回true</code></pre><p><strong>void add(int index, E element)</strong></p>
<pre><code>在集合指定位置index处增加一个元素e
如index超出集合下标范围，则报错</code></pre><p><strong>boolean addAll(Collection&lt;? extends E&gt; c)</strong></p>
<pre><code>在集合末尾增加一组元素
增加成功返回true</code></pre><p><strong>boolean contains(Object o)</strong></p>
<pre><code>集合中是否存在一个元素o
存在则返回true，否则返回false</code></pre><p><strong>E List.get(int index)</strong></p>
<pre><code>获取集合中给定下标index处的元素值
index超过集合下标返回则会报错
***注意：Collection中没有这个方法***</code></pre><p><strong>int indexOf(Object o)</strong></p>
<pre><code>返回给定值o在集合中第一次出现的位置
没有出现则返回-1</code></pre><p><strong>int lastIndexOf(Object o)</strong></p>
<pre><code>返回给定值o在集合中最后一次出现的位置
没有出现则返回-1</code></pre><p><strong>boolean isEmpty()</strong></p>
<pre><code>判断集合是否为空
为空则返回true，非空则返回false</code></pre><p><strong>E remove(int index)</strong></p>
<pre><code>移除集合中给定下标处的值
返回被移除的元素值
***注意：在Collection中，remove方法是给定值，移除集合中第一次出现该值的元素，
而List中则是给定下标，移除下标处的值***</code></pre><p><strong>E set(int index, E element)</strong></p>
<pre><code>将集合中给定下标index处的值更改为新值element
返回修改前的值</code></pre><p><strong>int size()</strong></p>
<pre><code>返回集合的大小
即集合中元素的个数</code></pre><p><strong>List<E> subList(int fromIndex, int toIndex)</E></strong></p>
<pre><code>返回一个子集合
子集合为父集合下标从fromIndex到toIndex之间的所有元素（左闭右开）</code></pre><p><strong><E> E[] toArray(E[] a)</E></strong></p>
<pre><code>集合转数组</code></pre><p><strong>void clear()</strong></p>
<pre><code>清空集合所有元素</code></pre><p><strong><E> void java.util.Collections.sort(List<E> list)</E></E></strong></p>
<pre><code>对集合进行升序排序</code></pre><hr>
<h2 id="3-测试代码"><a href="#3-测试代码" class="headerlink" title="##3. 测试代码"></a>##3. 测试代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class TestList &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		List&lt;Integer&gt; array&#x3D;new ArrayList&lt;Integer&gt;() ;</span><br><span class="line">		array.add(1);</span><br><span class="line">		array.add(5);</span><br><span class="line">		array.add(10);</span><br><span class="line">		array.add(6);&#x2F;&#x2F;增加元素</span><br><span class="line">		System.out.println(array);</span><br><span class="line">		&#x2F;&#x2F;输出：[1, 5, 10, 6]</span><br><span class="line">		</span><br><span class="line">		array.add(2, 2);&#x2F;&#x2F;在指定位置增加元素</span><br><span class="line">		System.out.println(array);</span><br><span class="line">		&#x2F;&#x2F;输出：[1, 5, 2, 10, 6]</span><br><span class="line">		</span><br><span class="line">		array.addAll(array);&#x2F;&#x2F;增加一组元素，</span><br><span class="line">		System.out.println(array);</span><br><span class="line">		&#x2F;&#x2F;输出：[1, 5, 2, 10, 6, 1, 5, 2, 10, 6]</span><br><span class="line">		</span><br><span class="line">		System.out.println(array.contains(2));</span><br><span class="line">		&#x2F;&#x2F;输出：true</span><br><span class="line">		System.out.println(array.contains(100));&#x2F;&#x2F;数组是否包含元素</span><br><span class="line">		&#x2F;&#x2F;输出：false</span><br><span class="line">		</span><br><span class="line">		System.out.println(array.get(1));&#x2F;&#x2F;获取指定下标的元素</span><br><span class="line">		&#x2F;&#x2F;输出：5</span><br><span class="line">		</span><br><span class="line">		System.out.println(array.indexOf(5));</span><br><span class="line">		&#x2F;&#x2F;输出：1</span><br><span class="line">		System.out.println(array.indexOf(8000));&#x2F;&#x2F;获取指定元素的下标（从前往后数第一个出现的），无该元素则返回-1</span><br><span class="line">		&#x2F;&#x2F;输出：-1</span><br><span class="line">		</span><br><span class="line">		System.out.println(array.lastIndexOf(6));</span><br><span class="line">		&#x2F;&#x2F;输出：9</span><br><span class="line">		System.out.println(array.lastIndexOf(8000));&#x2F;&#x2F;获取指定元素的下标（从后往前数第一个出现的），无该元素则返回-1</span><br><span class="line">		&#x2F;&#x2F;输出：-1</span><br><span class="line">		</span><br><span class="line">		System.out.println(array.isEmpty());&#x2F;&#x2F;数组是否为空，是空返回true，非空返回false</span><br><span class="line">		&#x2F;&#x2F;输出：false</span><br><span class="line">		</span><br><span class="line">		array.remove(1);&#x2F;&#x2F;移除数组指定下标的元素</span><br><span class="line">		System.out.println(array);</span><br><span class="line">		&#x2F;&#x2F;输出：[1, 2, 10, 6, 1, 5, 2, 10, 6]</span><br><span class="line">		</span><br><span class="line">		array.set(0, 8);&#x2F;&#x2F;将指定下标的元素值改为给定值</span><br><span class="line">		System.out.println(array);</span><br><span class="line">		&#x2F;&#x2F;输出：[8, 2, 10, 6, 1, 5, 2, 10, 6]</span><br><span class="line">		</span><br><span class="line">		System.out.println(array.size());&#x2F;&#x2F;获取数组的大小，即所有元素的个数</span><br><span class="line">		&#x2F;&#x2F;输出：9</span><br><span class="line">		</span><br><span class="line">		array&#x3D;array.subList(0, 5);</span><br><span class="line">		System.out.println(array);&#x2F;&#x2F;获取数组的子数组，需给出前后截取的范围，左闭右开</span><br><span class="line">		&#x2F;&#x2F;输出：[8, 2, 10, 6, 1]</span><br><span class="line">		</span><br><span class="line">		Integer[] a&#x3D;array.toArray(new Integer[array.size()]);&#x2F;&#x2F;集合转数组</span><br><span class="line">		for(int i&#x3D;0;i&lt;a.length;i++)</span><br><span class="line">			System.out.print(a[i]+&quot; &quot;);</span><br><span class="line">		System.out.println();</span><br><span class="line">		&#x2F;&#x2F;输出：8 2 10 6 1 </span><br><span class="line">		</span><br><span class="line">		Collections.sort(array);</span><br><span class="line">		System.out.println(array);&#x2F;&#x2F;对集合排序</span><br><span class="line">		&#x2F;&#x2F;输出：[1, 2, 6, 8, 10]</span><br><span class="line">		</span><br><span class="line">		array.clear();&#x2F;&#x2F;清空</span><br><span class="line">		System.out.println(array);</span><br><span class="line">		&#x2F;&#x2F;输出：[]</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-相关链接"><a href="#4-相关链接" class="headerlink" title="##4. 相关链接"></a>##4. 相关链接</h2><p><a href="https://dulaogou.vip/2020/07/13/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">Java集合框架</a><br><a href="https://dulaogou.vip/2020/07/13/Java%E9%9B%86%E5%90%88-Collection-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">Java集合-Collection</a><br><a href="https://dulaogou.vip/2020/07/14/Java%E9%9B%86%E5%90%88-Queue%E5%92%8CLinkedList-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">Java集合-Queue和LinkedList</a><br><a href="https://dulaogou.vip/2020/07/16/Java%E9%9B%86%E5%90%88-Map%E5%92%8CHashMap-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">Java集合-Map和HashMap</a><br><a href="https://dulaogou.vip/2020/07/16/Java%E9%9B%86%E5%90%88-%E5%90%84%E7%A7%8D%E9%9B%86%E5%90%88%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">Java集合-各种集合的使用场景</a></p>
]]></content>
      <categories>
        <category>Java知识点</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
        <tag>List</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合-Map和HashMap[Java知识点]</title>
    <url>/2020/07/16/Java%E9%9B%86%E5%90%88-Map%E5%92%8CHashMap-Java%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p><strong>相较于线性的集合如List，Queue，LinkedList之类的集合，Map和HashMap则是另一种完全不同的数据存储方式：键-值对。</strong></p>
<p><strong>也就是说，在Map中，数据并不是List中那样单个出现，互相不关联，而是成对出现，比如在一个Map中，我们这样记录数据：{1=5,2=10}，注意：这里的1=5,2=10并非数学上的等号关系，而是“对应”的关系，1和5是一对，2和10是一对。</strong></p>
<p><strong>在Map中，一对数据a=b，其中我们称a为“关键字（key）”或“键”，b为“值（value）”，键在Map中是唯一的，我们可以通过键来查找他对应的值。</strong><br>在应用中，我们常常使用Map来保存一些数据，如：统计每种商品的数量时，我们就可以使用Map，其中key为商品编号，对应的value为商品出现数量。这样做可以减少程序员的工作量。</p>
<p><strong>HashMap使用哈希算法对键去重复，效率高，但是无序。</strong><br><strong>Map是接口，HashMap是Map的主要实现类。定义方式：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义一个键和值类型都是Integer类型的map和hashmap</span><br><span class="line">Map&lt;Integer,Integer&gt; map&#x3D;new HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">&#x2F;&#x2F;或者</span><br><span class="line">HashMap&lt;Integer,Integer&gt; hashmap&#x3D;new HashMap&lt;Integer,Integer&gt;();</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<hr>
<h2 id="1-Map的常用方法"><a href="#1-Map的常用方法" class="headerlink" title="##1. Map的常用方法"></a>##1. Map的常用方法</h2><p><strong>E put(E key, E value)</strong></p>
<pre><code>在map中插入键-值对，key为关键字，value为对应值
如果map中已存在该关键字，则修改其对应值为value
如果是新插入的键值对，返回值为null
如果是修改了原关键字的对应值，返回值为被修改的value值</code></pre><p><strong>E putIfAbsent(E key, E value)</strong></p>
<pre><code>如果map中不存在关键字key，则插入该键值对，并返回null
如果已存在，什么也不做，返回-1</code></pre><p><strong>boolean containsKey(Object key)</strong></p>
<pre><code>判断map中是否存在关键字为key的键值对
存在则返回true，否则false</code></pre><p><strong>boolean containsValue(Object value)</strong></p>
<pre><code>判断map中是否存在对应值为value的键值对
存在则返回true，否则false</code></pre><p><strong>E get(Object key)</strong></p>
<pre><code>获取map中关键字为key的对应值
未找到则返回null</code></pre><p><strong>boolean isEmpty()</strong></p>
<pre><code>判断map是否为空</code></pre><p><strong>int size()</strong></p>
<pre><code>返回map中的元素个数</code></pre><p><strong>E remove(Object key)</strong></p>
<pre><code>删除map中关键字为key的元素
返回被删除的key的对应值
未找到则返回null</code></pre><p><strong>boolean remove(Object key, Object value)</strong></p>
<pre><code>删除map中关键字为key且值为value的元素
成功则返回true，失败返回false</code></pre><p><strong>E replace(E key, E value)</strong></p>
<pre><code>将map中，关键字为key的对应值改为value
返回被修改的值，未找到则返回null</code></pre><p><strong>boolean replace(E key, E oldValue, E newValue)</strong></p>
<pre><code>将map中，关键字为key且值为oldValue的元素的值修改为newValue
修改成功返回true，失败返回false</code></pre><p><strong>void clear()</strong></p>
<pre><code>清空map数据</code></pre><hr>
<h2 id="2-测试代码"><a href="#2-测试代码" class="headerlink" title="##2. 测试代码"></a>##2. 测试代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class TestMap &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Map&lt;Integer, Integer&gt; map&#x3D;new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">		</span><br><span class="line">		map.put(1, -1);</span><br><span class="line">		map.put(5, -5);</span><br><span class="line">		System.out.println(map);&#x2F;&#x2F;在map中插入键-值对</span><br><span class="line">		&#x2F;&#x2F;输出：&#123;1&#x3D;-1, 5&#x3D;-5&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(map.containsKey(1));&#x2F;&#x2F;map中是否存在关键字</span><br><span class="line">		&#x2F;&#x2F;输出：true</span><br><span class="line">		System.out.println(map.containsValue(-5));&#x2F;&#x2F;map中是否存在值</span><br><span class="line">		&#x2F;&#x2F;输出：true</span><br><span class="line"></span><br><span class="line">		map.putIfAbsent(1, -2);</span><br><span class="line">		System.out.println(map);&#x2F;&#x2F;如果存在关键字，则不操作</span><br><span class="line">		&#x2F;&#x2F;输出：&#123;1&#x3D;-1, 5&#x3D;-5&#125;</span><br><span class="line">		</span><br><span class="line">		map.putIfAbsent(3, -3);</span><br><span class="line">		System.out.println(map);&#x2F;&#x2F;如果不存在关键字，则插入键-值对</span><br><span class="line">		&#x2F;&#x2F;输出：&#123;1&#x3D;-1, 3&#x3D;-3, 5&#x3D;-5&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(map.get(3));&#x2F;&#x2F;返回关键字对应的值</span><br><span class="line">		&#x2F;&#x2F;输出：-3</span><br><span class="line">		System.out.println(map.get(7));&#x2F;&#x2F;不存在就返回null</span><br><span class="line">		&#x2F;&#x2F;输出：null</span><br><span class="line">		</span><br><span class="line">		System.out.println(map.isEmpty());&#x2F;&#x2F;判断是否为空</span><br><span class="line">		&#x2F;&#x2F;输出：false</span><br><span class="line">		</span><br><span class="line">		System.out.println(map.size());&#x2F;&#x2F;返回元素个数</span><br><span class="line">		&#x2F;&#x2F;输出：3</span><br><span class="line">		</span><br><span class="line">		map.remove(3);</span><br><span class="line">		System.out.println(map);&#x2F;&#x2F;移除map中关键字为3的键-值对</span><br><span class="line">		&#x2F;&#x2F;输出：&#123;1&#x3D;-1, 5&#x3D;-5&#125;</span><br><span class="line">		</span><br><span class="line">		map.remove(1, -5);</span><br><span class="line">		System.out.println(map);&#x2F;&#x2F;移除map中关键字为1且值为-5的键-值对，不存在则不操作</span><br><span class="line">		&#x2F;&#x2F;输出：&#123;1&#x3D;-1, 5&#x3D;-5&#125;</span><br><span class="line">		</span><br><span class="line">		map.replace(1, 2);</span><br><span class="line">		System.out.println(map);&#x2F;&#x2F;修改map中的键-值关系</span><br><span class="line">		&#x2F;&#x2F;输出：&#123;1&#x3D;2, 5&#x3D;-5&#125;</span><br><span class="line">		</span><br><span class="line">		map.replace(1, 1, 3);</span><br><span class="line">		System.out.println(map);&#x2F;&#x2F;修改map中的键值关系，不存在则不操作</span><br><span class="line">		&#x2F;&#x2F;输出：&#123;1&#x3D;2, 5&#x3D;-5&#125;</span><br><span class="line">				</span><br><span class="line">		map.clear();</span><br><span class="line">		System.out.println(map);&#x2F;&#x2F;清空map</span><br><span class="line">		&#x2F;&#x2F;输出：&#123;&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-相关链接"><a href="#3-相关链接" class="headerlink" title="##3. 相关链接"></a>##3. 相关链接</h2><p><a href="https://dulaogou.vip/2020/07/13/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">Java集合框架</a><br><a href="https://dulaogou.vip/2020/07/13/Java%E9%9B%86%E5%90%88-Collection-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">Java集合-Collection</a><br><a href="https://dulaogou.vip/2020/07/14/Java%E9%9B%86%E5%90%88-List%E5%92%8CArrayList-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">Java集合-List和ArrayList</a><br><a href="https://dulaogou.vip/2020/07/14/Java%E9%9B%86%E5%90%88-Queue%E5%92%8CLinkedList-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">Java集合-Queue和LinkedList</a><br><a href="https://dulaogou.vip/2020/07/16/Java%E9%9B%86%E5%90%88-%E5%90%84%E7%A7%8D%E9%9B%86%E5%90%88%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">Java集合-各种集合的使用场景</a></p>
]]></content>
      <categories>
        <category>Java知识点</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
        <tag>Map</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合-Queue和LinkedList[Java知识点]</title>
    <url>/2020/07/14/Java%E9%9B%86%E5%90%88-Queue%E5%92%8CLinkedList-Java%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p><strong>Queue接口是我们平常所说的队列（数据先进先出），LinkedList是他的一个实现类</strong><br><strong>如果我们想定义一个队列，以下两种方法都是可以的：</strong></p>
<pre><code>Queue&lt;E&gt; queue=new LinkedList&lt;E&gt;();
LinkedList&lt;E&gt; queue=new LinkedList&lt;E&gt;();</code></pre><p><strong><em>但必须注意：如果把他定义为Queue，那它就是一个纯粹的队列；</em></strong><br><strong><em>而如果定义成LinkedList，它除了实现Queue的方法外，还实现了List的许多方法，我们既可以把他当队列，还可以当做双向队列、链表、栈来使用他。</em></strong></p>
<a id="more"></a>

<hr>
<h2 id="1-Collection集合的继承树"><a href="#1-Collection集合的继承树" class="headerlink" title="##1. Collection集合的继承树"></a>##1. Collection集合的继承树</h2><img src="/2020/07/14/Java%E9%9B%86%E5%90%88-Queue%E5%92%8CLinkedList-Java%E7%9F%A5%E8%AF%86%E7%82%B9/1.jpg" class title="Collection集合的继承树">

<hr>
<h2 id="2-Queue的常用方法"><a href="#2-Queue的常用方法" class="headerlink" title="##2. Queue的常用方法"></a>##2. Queue的常用方法</h2><p><strong>boolean add(E e)</strong></p>
<pre><code>在队尾中增加新数据</code></pre><p><strong>boolean offer(E e)</strong></p>
<pre><code>在队尾增加新数据
与add()不同的是：当队列容量已满时，add()方法会抛出IllegalStateException异常，
而offer()方法会返回 false</code></pre><p><strong>E element()</strong></p>
<pre><code>获取队列头元素</code></pre><p><strong>E peek()</strong></p>
<pre><code>获取队列头元素
与element()不同的是：在队列元素为空的情况下，element() 方法会抛出NoSuchElementException异常，
而peek() 方法会返回 null</code></pre><p><strong>E poll()</strong></p>
<pre><code>删除队列头元素</code></pre><p><strong>boolean contains(Object o)</strong></p>
<pre><code>判断队列中是否存在元素o
存在返回true，否则返回false</code></pre><p><strong>boolean isEmpty()</strong></p>
<pre><code>判断队列是否为空
为空则返回true，否则返回false</code></pre><p><strong>int size()</strong></p>
<pre><code>获取队列的长度
即队列中元素的个数</code></pre><p><strong>boolean remove(Object o)</strong><br><strong>boolean remove(int index)</strong></p>
<pre><code>①. 如果定义的是Queue类型，则删除队列中第一个遇到的值等于o的元素；
②. 如果定义的是LinkedList类型，则删除队列中下标为index的元素。</code></pre><p><strong>void clear()</strong></p>
<pre><code>清空队列</code></pre><hr>
<h2 id="3-Queue测试代码"><a href="#3-Queue测试代码" class="headerlink" title="##3. Queue测试代码"></a>##3. Queue测试代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Queue;</span><br><span class="line"></span><br><span class="line">public class TestQueue &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Queue&lt;Integer&gt; queue&#x3D;new LinkedList&lt;Integer&gt;();</span><br><span class="line">		</span><br><span class="line">		queue.add(1);</span><br><span class="line">		queue.add(2);</span><br><span class="line">		System.out.println(queue);&#x2F;&#x2F;在队列中增加数据</span><br><span class="line">		&#x2F;&#x2F;输出：[1, 2]</span><br><span class="line">		</span><br><span class="line">		queue.offer(3);</span><br><span class="line">		System.out.println(queue);&#x2F;&#x2F;在队列中增加数据</span><br><span class="line">		&#x2F;&#x2F;输出：[1, 2,3]</span><br><span class="line">		</span><br><span class="line">		System.out.println(queue.element());&#x2F;&#x2F;获取队列头元素，不删除</span><br><span class="line">		&#x2F;&#x2F;输出：1</span><br><span class="line">		</span><br><span class="line">		System.out.println(queue.peek());&#x2F;&#x2F;获取队列头元素，不删除</span><br><span class="line">		&#x2F;&#x2F;输出：1</span><br><span class="line">		</span><br><span class="line">		queue.poll();</span><br><span class="line">		System.out.println(queue);&#x2F;&#x2F;删除队列头元素</span><br><span class="line">		&#x2F;&#x2F;输出：[2, 3]</span><br><span class="line">		</span><br><span class="line">		System.out.println(queue.contains(3));&#x2F;&#x2F;队列中是否存在该元素</span><br><span class="line">		&#x2F;&#x2F;输出：true</span><br><span class="line">		</span><br><span class="line">		System.out.println(queue.isEmpty());&#x2F;&#x2F;队列是否为空</span><br><span class="line">		&#x2F;&#x2F;输出：false</span><br><span class="line">		</span><br><span class="line">		queue.remove(2);</span><br><span class="line">		System.out.println(queue);&#x2F;&#x2F;删除队列中第一个值等于给定值的元素</span><br><span class="line">		&#x2F;&#x2F;输出：[3]</span><br><span class="line">		</span><br><span class="line">		System.out.println(queue.size());&#x2F;&#x2F;获取队列长度，即元素个数</span><br><span class="line">		&#x2F;&#x2F;输出：1</span><br><span class="line">		</span><br><span class="line">		queue.clear();</span><br><span class="line">		System.out.println(queue);&#x2F;&#x2F;清空队列</span><br><span class="line">		&#x2F;&#x2F;输出：[]</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-除了使用Queue定义的方法之外，LinkedList还能像链表和栈一样操作数据，常用方法如下"><a href="#4-除了使用Queue定义的方法之外，LinkedList还能像链表和栈一样操作数据，常用方法如下" class="headerlink" title="##4. 除了使用Queue定义的方法之外，LinkedList还能像链表和栈一样操作数据，常用方法如下"></a>##4. 除了使用Queue定义的方法之外，LinkedList还能像链表和栈一样操作数据，常用方法如下</h2><p><strong>void addFirst(E e)</strong></p>
<pre><code>从集合的头部插入元素</code></pre><p><strong>void addLast(E e)</strong></p>
<pre><code>从集合的尾部插入元素</code></pre><p><strong>E get(int index)</strong></p>
<pre><code>获取集合中给定下标处的值</code></pre><p><strong>E getFirst()</strong></p>
<pre><code>获取集合头部的值</code></pre><p><strong>E getLast()</strong></p>
<pre><code>获取集合尾部的值</code></pre><p><strong>int indexOf(Object o)</strong></p>
<pre><code>获取给定元素在集合中首次出现的下标</code></pre><p><strong>int lastIndexOf(Object o)</strong></p>
<pre><code>获取给定元素在集合中最后一次出现的下标</code></pre><p><strong>void push(E e)</strong></p>
<pre><code>往集合头部插入数据，像栈一样使用</code></pre><p><strong>E pop()</strong></p>
<pre><code>返回集合头部的数据，并删除
像栈一样使用</code></pre><hr>
<h2 id="5-LinkedList测试代码"><a href="#5-LinkedList测试代码" class="headerlink" title="##5. LinkedList测试代码"></a>##5. LinkedList测试代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">public class TestQueue &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		LinkedList&lt;Integer&gt; list&#x3D;new LinkedList&lt;Integer&gt;();</span><br><span class="line">		</span><br><span class="line">		list.addFirst(1);</span><br><span class="line">		list.addFirst(2);</span><br><span class="line">		list.addLast(5);</span><br><span class="line">		System.out.println(list);&#x2F;&#x2F;在数组头或尾插入数据</span><br><span class="line">		&#x2F;&#x2F;输出：[2, 1, 5]</span><br><span class="line">		</span><br><span class="line">		System.out.println(list.get(1));&#x2F;&#x2F;获取数组中给定下标处的值</span><br><span class="line">		&#x2F;&#x2F;输出：1</span><br><span class="line">		</span><br><span class="line">		System.out.println(list.getFirst());</span><br><span class="line">		&#x2F;&#x2F;输出：2</span><br><span class="line">		System.out.println(list.getLast());&#x2F;&#x2F;获取数组头或尾的值</span><br><span class="line">		&#x2F;&#x2F;输出：5</span><br><span class="line">		</span><br><span class="line">		System.out.println(list.indexOf(2));&#x2F;&#x2F;获取第一次出现值为2的位置</span><br><span class="line">		&#x2F;&#x2F;输出：0</span><br><span class="line">		System.out.println(list.lastIndexOf(1));&#x2F;&#x2F;获取最后一次出现值为1的位置</span><br><span class="line">		&#x2F;&#x2F;输出：1</span><br><span class="line">		</span><br><span class="line">		list.push(1);</span><br><span class="line">		System.out.println(list);&#x2F;&#x2F;从数组头插入数据</span><br><span class="line">		&#x2F;&#x2F;输出：[1, 2, 1, 5]</span><br><span class="line">		</span><br><span class="line">		list.pop();</span><br><span class="line">		System.out.println(list);&#x2F;&#x2F;从数组头删除数据</span><br><span class="line">		&#x2F;&#x2F;输出：[2, 1, 5]</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-相关链接"><a href="#6-相关链接" class="headerlink" title="##6. 相关链接"></a>##6. 相关链接</h2><p><a href="https://dulaogou.vip/2020/07/13/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">Java集合框架</a><br><a href="https://dulaogou.vip/2020/07/13/Java%E9%9B%86%E5%90%88-Collection-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">Java集合-Collection</a><br><a href="https://dulaogou.vip/2020/07/14/Java%E9%9B%86%E5%90%88-List%E5%92%8CArrayList-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">Java集合-List和ArrayList</a><br><a href="https://dulaogou.vip/2020/07/16/Java%E9%9B%86%E5%90%88-Map%E5%92%8CHashMap-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">Java集合-Map和HashMap</a><br><a href="https://dulaogou.vip/2020/07/16/Java%E9%9B%86%E5%90%88-%E5%90%84%E7%A7%8D%E9%9B%86%E5%90%88%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">Java集合-各种集合的使用场景</a></p>
]]></content>
      <categories>
        <category>Java知识点</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
        <tag>Queue</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合-各种集合的使用场景[Java知识点]</title>
    <url>/2020/07/16/Java%E9%9B%86%E5%90%88-%E5%90%84%E7%A7%8D%E9%9B%86%E5%90%88%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-Java%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p><strong>我们知道Java有许多的集合，如线性集合List，Set，Queue等，键-值对集合Map和HashMap，那我们应该怎么在具体问题中选择合适的集合来使用呢？</strong><br><em>注：本文大多知识来源于互联网，本人仅作整理，方便日后查找。</em></p>
<a id="more"></a>

<hr>
<h2 id="1-分类记录"><a href="#1-分类记录" class="headerlink" title="##1. 分类记录"></a>##1. 分类记录</h2><p><strong>1. ArrayList</strong></p>
<pre><code>ArrayList的底层实现是用数组的方式，随机访问比较快速，
即可以较为快捷地使用下标来直接访问数组中间的某个数据。
但是如果要频繁地插入删除元素，ArrayList会有移动元素的开销，
此时不建议使用ArrayList。</code></pre><p><strong>2. LinkedList</strong></p>
<pre><code>LinkedList底层是使用链表实现的，插入删除比较快，
但如果要随机访问或者遍历，效率就不如ArrayList了。</code></pre><p><strong>3. Stack和Queue</strong></p>
<pre><code>栈和队列，大家应该都不陌生，
Stack：数据先进后出，可以理解为只有一个出口的胡同，先进去的后出来。
Queue：数据先进先出，可以理解为银行排队，先到的先办理先走人。</code></pre><p><strong>4. Set</strong></p>
<pre><code>Set也是线性集合，和List的区别是：List中元素可以重复，而Set中元素不重复。</code></pre><p><strong>5. HashSet、TreeSet和LinkedHashSet</strong></p>
<pre><code>都是Set的实现类。
HashSet的性能总比TreeSet好，但不能保持数据的顺序。
如果需要频繁地添加、查找元素时，建议使用HashSet。
而如果需要一个保持排序的Set，用TreeSet。
如果需要遍历集合元素，用LinkedHashSet。

HashSet：通过散列法储存数据，查询很快。
LinkedHashSet：以元素插入的顺序来维护集合的链接表，允许以插入的顺序在集合中迭代。
TreeSet：以树结构存储Set接口的实现，对象按升序存储时，访问速度很快。</code></pre><p><strong>6. Map和HashMap</strong></p>
<pre><code>当我们需要通过数据的代号来获取数据时可以使用Map。
Map中键不能重复。
数据呈现的是对应关系，如 学号-姓名 这种对应关系。
HashMap是Map的具体实现类。</code></pre><hr>
<h2 id="2-相关链接"><a href="#2-相关链接" class="headerlink" title="##2. 相关链接"></a>##2. 相关链接</h2><p><a href="https://dulaogou.vip/2020/07/13/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">Java集合框架</a><br><a href="https://dulaogou.vip/2020/07/13/Java%E9%9B%86%E5%90%88-Collection-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">Java集合-Collection</a><br><a href="https://dulaogou.vip/2020/07/14/Java%E9%9B%86%E5%90%88-List%E5%92%8CArrayList-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">Java集合-List和ArrayList</a><br><a href="https://dulaogou.vip/2020/07/14/Java%E9%9B%86%E5%90%88-Queue%E5%92%8CLinkedList-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">Java集合-Queue和LinkedList</a><br><a href="https://dulaogou.vip/2020/07/16/Java%E9%9B%86%E5%90%88-Map-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">Java集合-Map和HashMap</a></p>
]]></content>
      <categories>
        <category>Java知识点</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合框架[Java知识点]</title>
    <url>/2020/07/13/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-Java%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p><strong>声明：本文内容来自于菜鸟教程(<a href="https://www.runoob.com/java/java-collections.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-collections.html</a>)<br>我仅作部分修改。万分感谢，如有侵权，联系我QQ：965299766删除。</strong></p>
<hr>
<p>Java提供了一系列集合类供我们使用，可以帮我们实现一些数据的操作。<br><strong>为什么要有集合？</strong><br>在Java中，我们平常使用的数组，如int[]，是定长的，即定义时就已经确定了他的长度。而很多时候我们需要对数组元素进行增删改查，定长数组就不方便了，于是就有了集合。</p>
<a id="more"></a>

<p> 集合框架被设计成要满足以下几个目标。</p>
<pre><code>该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。

该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。

对一个集合的扩展和适应必须是简单的。</code></pre><p>为此，整个集合框架就围绕一组标准接口而设计。你可以直接使用这些接口的标准实现，诸如： LinkedList, HashSet, 和 TreeSet 等,除此之外你也可以通过这些接口实现自己的集合。</p>
<img src="/2020/07/13/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-Java%E7%9F%A5%E8%AF%86%E7%82%B9/1.jpg" class title="Java集合框架图">

<p>从上面的集合框架图可以看到，Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等等。</p>
<p>集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：</p>
<pre><code>接口：是代表集合的抽象数据类型。
例如 Collection、List、Set、Map 等。
之所以定义多个接口，是为了以不同的方式操作集合对象

实现（类）：是集合接口的具体实现。
从本质上讲，它们是可重复使用的数据结构，
例如：ArrayList、LinkedList、HashSet、HashMap。

算法：是实现集合接口的对象里的方法执行的一些有用的计算，
例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。</code></pre><p>除了集合，该框架也定义了几个 Map 接口和类。Map 里存储的是键/值对。尽管 Map 不是集合，但是它们完全整合在集合中。</p>
<p><strong>集合框架体系如图所示</strong></p>
<img src="/2020/07/13/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-Java%E7%9F%A5%E8%AF%86%E7%82%B9/2.jpg" class title="集合框架体系图">
<p>Java 集合框架提供了一套性能优良，使用方便的接口和类，java集合框架位于java.util包中， 所以当使用集合框架的时候需要进行导包。</p>
<hr>
<p><strong>相关链接</strong></p>
<p><a href="https://dulaogou.vip/2020/07/13/Java%E9%9B%86%E5%90%88-Collection-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">Java集合-Collection</a><br><a href="https://dulaogou.vip/2020/07/14/Java%E9%9B%86%E5%90%88-List%E5%92%8CArrayList-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">Java集合-List和ArrayList</a><br><a href="https://dulaogou.vip/2020/07/14/Java%E9%9B%86%E5%90%88-Queue%E5%92%8CLinkedList-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">Java集合-Queue和LinkedList</a><br><a href="https://dulaogou.vip/2020/07/16/Java%E9%9B%86%E5%90%88-Map%E5%92%8CHashMap-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">Java集合-Map和HashMap</a><br><a href="https://dulaogou.vip/2020/07/16/Java%E9%9B%86%E5%90%88-%E5%90%84%E7%A7%8D%E9%9B%86%E5%90%88%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">Java集合-各种集合的使用场景</a></p>
]]></content>
      <categories>
        <category>Java知识点</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda表达式-基础部分[Java知识点]</title>
    <url>/2020/07/17/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86-Java%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p><strong>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。</strong></p>
<p><strong>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。</strong></p>
<p><strong>使用 Lambda 表达式可以使代码变的更加简洁紧凑。</strong><br><em>以上来自：</em><a href="https://www.runoob.com/java/java8-lambda-expressions.html" target="_blank" rel="noopener">菜鸟教程-Lambda表达式</a></p>
<p><strong>使用Lambda表达式能够将一个接口非常简洁地实现，从而使代码更简洁。</strong></p>
<a id="more"></a>

<hr>
<h2 id="1-先举个例子"><a href="#1-先举个例子" class="headerlink" title="##1. 先举个例子"></a>##1. 先举个例子</h2><p>我们先假设有一个接口TestInterface，里面声明了一个函数func()：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface TestInterface&#123;&#x2F;&#x2F;接口</span><br><span class="line">	int func(int a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们是如何实现这个接口的呢？学习Lambda表达式之前，我们一般用两种方法来实现接口：</p>
<p><strong>1.1. 通过接口实现类</strong><br>首先定义该接口的实现类，然后完成接口中的方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Realize implements TestInterface&#123;&#x2F;&#x2F;定义接口的实现类</span><br><span class="line">	@Override</span><br><span class="line">	public int func(int a) &#123;&#x2F;&#x2F;方法具体实现</span><br><span class="line">		System.out.println(a+&quot;*2&#x3D;&quot;+a*2);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做到了这步，我们就可以用这个实现类来创建对象调用func函数了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;1. 通过接口实现类</span><br><span class="line">	Realize r&#x3D;new Realize();</span><br><span class="line">	r.func(5);</span><br><span class="line">	&#x2F;&#x2F;输出：5*2&#x3D;10</span><br></pre></td></tr></table></figure>

<p><strong>1.2. 通过匿名内部类</strong><br>我们直接声明接口的一个匿名内部类，构造内部类的时候我们同时将函数实现完成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;2. 通过匿名内部类</span><br><span class="line">	TestInterface testInterface&#x3D;new TestInterface() &#123;</span><br><span class="line">		@Override</span><br><span class="line">		public int func(int a) &#123;</span><br><span class="line">			System.out.println(&quot;a&#x3D;&quot;+a);</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<p>此时，我们也可以使用func方法了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">testInterface.func(8);</span><br><span class="line">&#x2F;&#x2F;输出：a&#x3D;8</span><br></pre></td></tr></table></figure>

<p><strong>第二种方法相较于第一种方法稍微简单些，但如果使用Lambda表达式，就可以简化为一行代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;3. 使用lambda表达式</span><br><span class="line">TestInterface test2&#x3D;(a)-&gt;&#123;return a * 3;&#125;;</span><br></pre></td></tr></table></figure>
<p>调用func方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int ans&#x3D;test2.func(6);</span><br><span class="line">System.out.println(ans);</span><br><span class="line">&#x2F;&#x2F;输出：18</span><br></pre></td></tr></table></figure>
<p><strong>很显然，使用Lambda表达式极大地简化了我们的代码，使程序更为简洁。</strong><br><strong>那么我们如何使用呢？</strong></p>
<hr>
<h2 id="2-接口准备"><a href="#2-接口准备" class="headerlink" title="##2. 接口准备"></a>##2. 接口准备</h2><p><strong>能用Lambda表达式的接口都是只有一个函数声明的，对此，我们可以使用 @FunctionalInterface 来修饰接口，保证该接口只有一个函数声明。</strong></p>
<p>我们提前准备以下6个接口供后续讲解使用，里面分别各有一个函数声明：<br><strong>①. 函数为无参数无返回值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface NoneReturnNoneParameter &#123;&#x2F;&#x2F;无参数无返回值</span><br><span class="line">	void test();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>②. 函数为有一个参数无返回值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface NoneReturnSingleParameter &#123;&#x2F;&#x2F;有一个参数无返回值</span><br><span class="line">	void test(int a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>③. 函数为有多个参数无返回值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface NoneReturnMultipleParameter &#123;&#x2F;&#x2F;有多个参数无返回值</span><br><span class="line">	void test(int a,int b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>④. 函数为无参数有返回值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface SingleReturnNoneParameter &#123;&#x2F;&#x2F;无参数有返回值</span><br><span class="line">	int test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>⑤. 函数为有一个参数有返回值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface SingleReturnSingleParameter &#123;&#x2F;&#x2F;有一个参数有返回值</span><br><span class="line">	int test(int a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>⑥. 函数为有多个参数有返回值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface SingleReturnMultipleParameter &#123;&#x2F;&#x2F;有多个参数有返回值</span><br><span class="line">	int test(int a,int b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-Lambda基本语法"><a href="#3-Lambda基本语法" class="headerlink" title="##3. Lambda基本语法"></a>##3. Lambda基本语法</h2><p><strong>对于Lambda表达式，我们要关心的就是函数的参数列表及方法主体，而方法名和返回值类型均被忽略。</strong></p>
<p><strong>在Lambda中，我们用 () 来描述参数列表，用 {} 来描述方法主体，这和平常的函数是一样的。</strong></p>
<p><strong>在()中间写参数列表，在{}中间写上方法主体。</strong></p>
<p><strong>用 -&gt; 来连接参数列表和方法主体，-&gt; 读作 “goes to” ，是Lambda运算符。</strong></p>
<hr>
<p><strong>对拥有以上6种不同参数和返回值方法的接口，我们分别进行实现：</strong></p>
<p><strong>3.1. 无参数无返回值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;1. 无参数无返回值</span><br><span class="line">	NoneReturnNoneParameter test1&#x3D;() -&gt; &#123;</span><br><span class="line">		System.out.println(&quot;无参数无返回值的方法实现了&quot;);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	test1.test();&#x2F;&#x2F;测试</span><br><span class="line">	&#x2F;&#x2F;输出：无参数无返回值的方法实现了</span><br></pre></td></tr></table></figure>

<p><strong>3.2. 有一个参数无返回值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;2. 有一个参数无返回值</span><br><span class="line">	NoneReturnSingleParameter test2 &#x3D; (int a) -&gt; &#123;</span><br><span class="line">		System.out.println(&quot;有一个参数无返回值的方法实现了，参数a&#x3D;&quot;+a);</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	test2.test(5);&#x2F;&#x2F;测试</span><br><span class="line">	&#x2F;&#x2F;输出：有一个参数无返回值的方法实现了，参数a&#x3D;5</span><br></pre></td></tr></table></figure>

<p><strong>3.3. 有多个参数无返回值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;3. 有多个参数无返回值</span><br><span class="line">	NoneReturnMultipleParameter test3 &#x3D; (int a,int b) -&gt; &#123;</span><br><span class="line">			System.out.println(&quot;有多个参数无返回值的方法实现了，参数a&#x3D;&quot;+a+&quot;，参数b&#x3D;&quot;+b);</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	test3.test(1, 3);&#x2F;&#x2F;测试</span><br><span class="line">	&#x2F;&#x2F;输出：有多个参数无返回值的方法实现了，参数a&#x3D;1，参数b&#x3D;3</span><br></pre></td></tr></table></figure>

<p><strong>3.4. 无参数有返回值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;4. 无参数有返回值</span><br><span class="line">	SingleReturnNoneParameter test4 &#x3D; () -&gt; &#123;</span><br><span class="line">			System.out.println(&quot;无参数有返回值的方法实现了&quot;);</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	int ret &#x3D; test4.test();&#x2F;&#x2F;测试</span><br><span class="line">	System.out.println(&quot;返回值为：&quot;+ret);</span><br><span class="line">	&#x2F;&#x2F;输出：无参数有返回值的方法实现了</span><br><span class="line">	&#x2F;&#x2F;返回值为：1</span><br></pre></td></tr></table></figure>

<p><strong>3.5. 有一个参数有返回值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;5. 有一个参数有返回值</span><br><span class="line">	SingleReturnSingleParameter test5 &#x3D; (int a) -&gt; &#123;</span><br><span class="line">			System.out.println(&quot;有一个参数有返回值的方法实现了&quot;);</span><br><span class="line">		return a * 2;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	int ret1 &#x3D; test5.test(10);&#x2F;&#x2F;测试</span><br><span class="line">	System.out.println(&quot;返回值为：&quot;+ret1);</span><br><span class="line">	&#x2F;&#x2F;输出：有一个参数有返回值的方法实现了</span><br><span class="line">	&#x2F;&#x2F;返回值为：20</span><br></pre></td></tr></table></figure>

<p><strong>3.6. 有多个参数有返回值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;6. 有多个参数有返回值</span><br><span class="line">	SingleReturnMultipleParameter test6 &#x3D; (int a,int b) -&gt; &#123;</span><br><span class="line">			System.out.println(&quot;有多个参数有返回值的方法实现了&quot;);</span><br><span class="line">		return a + b;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	int ret2 &#x3D; test6.test(10, 12);&#x2F;&#x2F;测试</span><br><span class="line">	System.out.println(&quot;返回值为：&quot;+ret2);</span><br><span class="line">	&#x2F;&#x2F;输出：有多个参数有返回值的方法实现了</span><br><span class="line">	&#x2F;&#x2F;返回值为：22</span><br></pre></td></tr></table></figure>

<p><strong>其实都还是挺简单的。</strong></p>
<hr>
<h2 id="4-语法精简"><a href="#4-语法精简" class="headerlink" title="##4. 语法精简"></a>##4. 语法精简</h2><p><strong>对于一些特殊情况，Lambda表达式还可以进一步精简。</strong></p>
<p><strong>4.1. 由于在接口中声明函数时就已经声明了参数的类型了，所以在写Lambda表达式时，参数类型可以省略。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;1. 因为在接口声明函数时已经声明了参数类型了，所以在Lambda表达式中可以省略参数类型</span><br><span class="line">	NoneReturnMultipleParameter test1 &#x3D; (a,b) -&gt; &#123;&#x2F;&#x2F;注意：原写法中a和b都是有int修饰的，我们可以将int修饰去掉，仍然正确</span><br><span class="line">		System.out.println(&quot;a&#x3D;&quot;+a+&quot;,b&#x3D;&quot;+b);</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	test1.test(3, 4);&#x2F;&#x2F;测试</span><br><span class="line">	&#x2F;&#x2F;输出：a&#x3D;3,b&#x3D;4</span><br></pre></td></tr></table></figure>
<p><strong><em>特别注意：如果要省略参数类型，则每一个参数类型都必须同时省略！</em></strong></p>
<p><strong>4.2. 如果参数列表中只有一个参数，那么包围参数的小括号 （）也可以省略。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;2. 如果参数列表中只有一个参数，那么包围参数的小括号 （）也可以省略</span><br><span class="line">	NoneReturnSingleParameter test2 &#x3D; a -&gt; &#123;&#x2F;&#x2F;注意：原写法中a是由小括号（）包围的，若只有一个参数，那么可以省略小括号</span><br><span class="line">		System.out.println(&quot;a&#x3D;&quot;+a);</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	test2.test(5);&#x2F;&#x2F;测试</span><br><span class="line">	&#x2F;&#x2F;输出：a&#x3D;5</span><br></pre></td></tr></table></figure>

<p><strong>4.3. 如果方法体只有一条语句，那么包围方法体的大括号 {} 也可以省略。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;3. 如果方法体只有一条语句，那么包围方法体的大括号 &#123;&#125; 也可以省略</span><br><span class="line">	NoneReturnSingleParameter test3 &#x3D; a -&gt; System.out.println(&quot;a&#x3D;&quot;+a);</span><br><span class="line">		</span><br><span class="line">	test3.test(8);&#x2F;&#x2F;测试</span><br><span class="line">	&#x2F;&#x2F;输出：a&#x3D;8</span><br></pre></td></tr></table></figure>

<p><strong>4.4. 如果4.3中方法体中唯一一条语句是 return 语句，那么关键词return 也必须省略。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;4. 如果3中方法体中唯一一条语句是 return 语句，那么关键词return 也必须省略</span><br><span class="line">		SingleReturnNoneParameter test4 &#x3D; () -&gt; 10;</span><br><span class="line">		</span><br><span class="line">		int ret &#x3D; test4.test();&#x2F;&#x2F;测试</span><br><span class="line">		System.out.println(&quot;返回值为：&quot;+ret);</span><br><span class="line">		&#x2F;&#x2F;输出：返回值为：10</span><br></pre></td></tr></table></figure>

<p><strong>发现Lambda表达式又在原基础上精简了不少。</strong></p>
<p><strong>Lambda表达式的基础部分至此结束。</strong></p>
<hr>
<h2 id="5-相关链接"><a href="#5-相关链接" class="headerlink" title="##5. 相关链接"></a>##5. 相关链接</h2><p><a href="https://dulaogou.vip/2020/07/19/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E8%BF%9B%E9%98%B6%E9%83%A8%E5%88%86-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">Lambda表达式-进阶部分</a></p>
]]></content>
      <categories>
        <category>Java知识点</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Lambda表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda表达式-进阶部分[Java知识点]</title>
    <url>/2020/07/19/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E8%BF%9B%E9%98%B6%E9%83%A8%E5%88%86-Java%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p><strong>本文在 <a href="https://dulaogou.vip/2020/07/17/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">Lambda表达式基础部分</a>的基础上介绍了一些Lambda表达式的进阶用法。</strong></p>
<p><strong>仅供参考</strong></p>
<a id="more"></a>

<hr>
<h2 id="1-方法引用"><a href="#1-方法引用" class="headerlink" title="##1. 方法引用"></a>##1. 方法引用</h2><p><strong>如果需要在程序中多次实现同一个接口，我们可能会写成如下形式：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SingleReturnSingleParameter lambda1 &#x3D; a -&gt; a * 2;</span><br><span class="line">	</span><br><span class="line">SingleReturnSingleParameter lambda2 &#x3D; a -&gt; a  * 2;</span><br><span class="line">&#x2F;&#x2F;......</span><br></pre></td></tr></table></figure>

<p><strong>显然，这种写法中，函数实现部分是有重复的，这样写，我们后续如果需要对接口的实现方法进行修改的话，就必须把每个实现的语句都修改一遍。</strong><br>如上方所示程序中，接口的实现函数是 <strong>a -&gt; a * 2</strong> ，如果想要把返回值从 a * 2 改为 a * 3的话，就需要对每个 a * 2 进行修改，此时，我们可以使用方法引用，将重复的部分用函数封装，从而方便了后续修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Syntax3 &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SingleReturnSingleParameter lambda1 &#x3D; a -&gt; change(a);</span><br><span class="line">		</span><br><span class="line">		SingleReturnSingleParameter lambda2 &#x3D; a -&gt; change(a);</span><br><span class="line">		&#x2F;&#x2F;......</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static int change(int a) &#123;&#x2F;&#x2F;写成一个函数</span><br><span class="line">		return a * 2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以这么写，使用 <strong>隶属者::方法名</strong> 的方式来引用方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SingleReturnSingleParameter lambda1 &#x3D; Syntax3 :: change;</span><br><span class="line">	</span><br><span class="line">SingleReturnSingleParameter lambda2 &#x3D; Syntax3 :: change;</span><br><span class="line">&#x2F;&#x2F;......</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-构造方法引用"><a href="#2-构造方法引用" class="headerlink" title="##2. 构造方法引用"></a>##2. 构造方法引用</h2><p><strong>那如果我们想引用的方法是一个类的构造方法呢？</strong></p>
<p>先写一个测试类Person，其中有一个无参构造和一个有参构造：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">	public Person() &#123;</span><br><span class="line">		System.out.println(&quot;Person的无参构造执行了&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public Person(int a , int b) &#123;</span><br><span class="line">		System.out.println(&quot;Person的有参构造执行了，参数a&#x3D;&quot;+a+&quot;,b&#x3D;&quot;+b);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于调用无参构造和有参构造，分别写两个接口。</p>
<p><strong>注意：接口中的方法参数必须和要实现的构造函数参数一致！</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">interface Person1&#123;</span><br><span class="line">	Person getPerson();&#x2F;&#x2F;调用无参构造</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@FunctionalInterface</span><br><span class="line">interface Person2&#123;</span><br><span class="line">	Person getPerson(int a , int b);&#x2F;&#x2F;调用有参构造</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对于不同的接口方法参数，使用Lambda表达式时会调用不同的构造函数</strong></p>
<p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Syntax &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;调用Person类的无参构造</span><br><span class="line">		Person1 person1 &#x3D; () -&gt; new Person();</span><br><span class="line">		Person1 person2 &#x3D; Person::new;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;测试</span><br><span class="line">		person1.getPerson();</span><br><span class="line">		&#x2F;&#x2F;输出：Person的无参构造执行了</span><br><span class="line">		person2.getPerson();</span><br><span class="line">		&#x2F;&#x2F;输出：Person的无参构造执行了</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;调用Person类的有参构造</span><br><span class="line">		Person2 person3 &#x3D; (a , b) -&gt; new Person(a , b);</span><br><span class="line">		Person2 person4 &#x3D; Person::new;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;测试</span><br><span class="line">		person3.getPerson(1, 5);</span><br><span class="line">		&#x2F;&#x2F;输出：Person的有参构造执行了，参数a&#x3D;1,b&#x3D;5</span><br><span class="line">		person4.getPerson(2, 3);</span><br><span class="line">		&#x2F;&#x2F;输出：Person的有参构造执行了，参数a&#x3D;2,b&#x3D;3</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@FunctionalInterface</span><br><span class="line">interface Person1&#123;</span><br><span class="line">	Person getPerson();&#x2F;&#x2F;调用无参构造</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@FunctionalInterface</span><br><span class="line">interface Person2&#123;</span><br><span class="line">	Person getPerson(int a , int b);&#x2F;&#x2F;调用有参构造</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-实际运用"><a href="#3-实际运用" class="headerlink" title="##3. 实际运用"></a>##3. 实际运用</h2><p><strong>3.1. 需求</strong><br>给定一个Person类，属性有姓名（String name），年龄（int age）。<br>给定一个Person类型的ArrayList，里面有10个随机的Person对象。<br>要求：使用ArrayList.sort()函数将其中的Person对象按年龄降序排序。</p>
<p><strong>3.2. Person类</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">	private String name;</span><br><span class="line">	private int age;</span><br><span class="line">	</span><br><span class="line">	public Person(String name,int age) &#123;</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">		this.age &#x3D; age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public int getAge() &#123;</span><br><span class="line">		return this.age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		String ret &#x3D; &quot;姓名：&quot; + this.name + &quot;年龄：&quot; + this.age+&quot;\n&quot;;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.3. ArrayList</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Person&gt; list &#x3D; new ArrayList&lt;Person&gt;();</span><br><span class="line">	</span><br><span class="line">&#x2F;&#x2F;10个随机Person对象</span><br><span class="line">list.add(new Person(&quot;xiaoming&quot;,10));</span><br><span class="line">list.add(new Person(&quot;laogou&quot;,15));</span><br><span class="line">list.add(new Person(&quot;zhangsan&quot;,7));</span><br><span class="line">list.add(new Person(&quot;lisi&quot;,5));</span><br><span class="line">list.add(new Person(&quot;wangwu&quot;,18));</span><br><span class="line">list.add(new Person(&quot;maliu&quot;,20));</span><br><span class="line">list.add(new Person(&quot;tianqi&quot;,2));</span><br><span class="line">list.add(new Person(&quot;wangwang&quot;,13));</span><br><span class="line">list.add(new Person(&quot;honghong&quot;,10));</span><br><span class="line">list.add(new Person(&quot;zhaoshu&quot;,55));</span><br></pre></td></tr></table></figure>

<p><strong>3.4. sort()函数</strong><br>sort函数形式如下：</p>
<pre><code>void sort(Comparator&lt;? super Person&gt; c)</code></pre><p>这其中的一个参数Comparator&lt;&gt; c是个啥？</p>
<p><strong>查看源码得知，这是一个函数式接口</strong></p>
<img src="/2020/07/19/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E8%BF%9B%E9%98%B6%E9%83%A8%E5%88%86-Java%E7%9F%A5%E8%AF%86%E7%82%B9/1.jpg" class title="函数式接口Comparator">

<p>其中有个待实现函数compare：</p>
<img src="/2020/07/19/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E8%BF%9B%E9%98%B6%E9%83%A8%E5%88%86-Java%E7%9F%A5%E8%AF%86%E7%82%B9/2.jpg" class title="待实现函数compare">

<p>它的作用是：<br><strong>对于参数o1和o2，如果返回值为正数，说明o1＞o2；</strong><br><strong>如果返回值为负数，说明o1＜o2；</strong><br><strong>如果返回值为0，说明o1=o2。</strong></p>
<p>至此，我们就可以实现这个函数式接口了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list.sort((o1 , o2) -&gt; o2.getAge() - o1.getAge());</span><br></pre></td></tr></table></figure>
<p>这样是降序排序，如果要升序，则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list.sort((o1 , o2) -&gt; o1.getAge() - o2.getAge());</span><br></pre></td></tr></table></figure>

<p><strong>3.5. 完整代码如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class Example &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		ArrayList&lt;Person&gt; list &#x3D; new ArrayList&lt;Person&gt;();</span><br><span class="line">		</span><br><span class="line">		list.add(new Person(&quot;xiaoming&quot;,10));</span><br><span class="line">		list.add(new Person(&quot;laogou&quot;,15));</span><br><span class="line">		list.add(new Person(&quot;zhangsan&quot;,7));</span><br><span class="line">		list.add(new Person(&quot;lisi&quot;,5));</span><br><span class="line">		list.add(new Person(&quot;wangwu&quot;,18));</span><br><span class="line">		list.add(new Person(&quot;maliu&quot;,20));</span><br><span class="line">		list.add(new Person(&quot;tianqi&quot;,2));</span><br><span class="line">		list.add(new Person(&quot;wangwang&quot;,13));</span><br><span class="line">		list.add(new Person(&quot;honghong&quot;,10));</span><br><span class="line">		list.add(new Person(&quot;zhaoshu&quot;,55));</span><br><span class="line">		</span><br><span class="line">		list.sort((o1 , o2) -&gt; o2.getAge() - o1.getAge());</span><br><span class="line">		</span><br><span class="line">		System.out.println(list);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.6. 运行结果图：</strong></p>
<img src="/2020/07/19/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E8%BF%9B%E9%98%B6%E9%83%A8%E5%88%86-Java%E7%9F%A5%E8%AF%86%E7%82%B9/3.jpg" class title="运行结果图">

<hr>
<h2 id="4-相关链接"><a href="#4-相关链接" class="headerlink" title="##4. 相关链接"></a>##4. 相关链接</h2><p><a href="https://dulaogou.vip/2020/07/17/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86-Java%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">Lambda表达式-基础部分</a></p>
]]></content>
      <categories>
        <category>Java知识点</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Lambda表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 101.对称二叉树[二叉树]</title>
    <url>/2020/07/06/LeetCode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="##1. 题目描述"></a>##1. 题目描述</h2><p><em>标签：[二叉树]</em></p>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
<a id="more"></a>


<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<pre><code>    1
   / \
  2   2
 / \ / \
3  4 4  3</code></pre><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<pre><code>  1
 / \
2   2
 \   \
 3    3</code></pre><hr>
<h2 id="2-题解"><a href="#2-题解" class="headerlink" title="##2. 题解"></a>##2. 题解</h2><p><strong>###2.1. 思路</strong><br>我们可以使用两个指针，开始时均指向根节点，然后让他们同时行动，进行深度优先搜索或广度优先搜索，当一个指针p指向了当前树节点的左子树节点时，我们让另一个指针q同时指向当前节点的右子树节点，然后比较p和q所指节点的值是否相等。<br>如果遇到p和q节点的值不等或者p和q不同时为空的情况下，返回false。<br>如果搜索完成后没有发现以上情况，返回true。</p>
<p><strong>###2.2. 代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TreeNode &#123;</span><br><span class="line">	 int val;</span><br><span class="line">	 TreeNode left;</span><br><span class="line">	 TreeNode right;</span><br><span class="line">	 TreeNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class IsSymmetric &#123;</span><br><span class="line">	public static boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">        return check(root,root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	public static boolean check(TreeNode p, TreeNode q) &#123;</span><br><span class="line">		if(p&#x3D;&#x3D;null&amp;&amp;q&#x3D;&#x3D;null)	&#x2F;&#x2F;如果两节点都为空，返回true</span><br><span class="line">			return true;</span><br><span class="line">		if(p&#x3D;&#x3D;null||q&#x3D;&#x3D;null)	&#x2F;&#x2F;如果只有一节点为空，返回false</span><br><span class="line">			return false;</span><br><span class="line">		</span><br><span class="line">		return p.val&#x3D;&#x3D;q.val&amp;&amp;check(p.right,q.left)&amp;&amp;check(p.left,q.right);&#x2F;&#x2F;两节点都不为空，递归进行比较</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;测试用例：二叉树 [1,2,2,3,4,4,3]</span><br><span class="line">		TreeNode tree&#x3D;new TreeNode(1);</span><br><span class="line">		tree.left&#x3D;new TreeNode(2);</span><br><span class="line">		tree.left.left&#x3D;new TreeNode(3);</span><br><span class="line">		tree.left.right&#x3D;new TreeNode(4);</span><br><span class="line">		</span><br><span class="line">		tree.right&#x3D;new TreeNode(2);</span><br><span class="line">		tree.right.left&#x3D;new TreeNode(4);</span><br><span class="line">		tree.right.right&#x3D;new TreeNode(3);</span><br><span class="line">		</span><br><span class="line">		System.out.println(isSymmetric(tree));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例：<br>二叉树 [1,2,2,3,4,4,3]</p>
<pre><code>    1
   / \
  2   2
 / \ / \
3  4 4  3</code></pre><p>测试结果：true<br>显然该树是对称的。</p>
<p><strong>LeetCode提交记录</strong></p>
<img src="/2020/07/06/LeetCode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91-%E4%BA%8C%E5%8F%89%E6%A0%91/result.jpg" class title="提交记录">

<hr>
<p>如有错误，欢迎联系本人QQ：965299766</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 11. 盛最多水的容器[数组][双指针]</title>
    <url>/2020/07/20/LeetCode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8-%E6%95%B0%E7%BB%84-%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="##1. 题目描述"></a>##1. 题目描述</h2><p><em>标签：[数组][双指针]</em></p>
<p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p><strong>说明：你不能倾斜容器，且 n 的值至少为 2。</strong></p>
<img src="/2020/07/20/LeetCode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8-%E6%95%B0%E7%BB%84-%E5%8F%8C%E6%8C%87%E9%92%88/question.jpg" class title="问题示例">

<p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p>
<a id="more"></a>

<p><strong>示例：</strong></p>
<p>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49</p>
<hr>
<h2 id="2-题解"><a href="#2-题解" class="headerlink" title="##2. 题解"></a>##2. 题解</h2><p><strong>2.1. 暴力解法</strong></p>
<p>这题的暴力解法不难想到，使用两个指针分别从数组的前后逼近中间，分别求面积，再得到面积的最大值就行了。</p>
<p><strong>两指针分别代表形成容器的左壁和右壁，而能装水的体积取决于：①. 左右壁高度的较小者；②. 左右壁之间的距离。</strong></p>
<p><strong>那此时我们只需要遍历所有能形成容器的情况，即遍历所有可能出现的左右壁组合，将左右壁较小者乘上左右壁距离即可得到装水的体积。遍历过程中求出体积的最大值就行了。</strong></p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MaxArea &#123;</span><br><span class="line">	public static int maxArea(int[] height) &#123;</span><br><span class="line">	       int len &#x3D; height.length;</span><br><span class="line">	       int max &#x3D; 0;</span><br><span class="line">	       for(int i &#x3D; 0;i &lt; len - 1;i++)&#123;</span><br><span class="line">	           for(int j &#x3D; len - 1;j &gt; i ;j--)&#123;</span><br><span class="line">	               int water &#x3D; height[i] &gt; height[j] ? height[j] * (j - i) : height[i] * (j - i);</span><br><span class="line">	               max &#x3D; Math.max(max,water);</span><br><span class="line">	           &#125;</span><br><span class="line">	       &#125;</span><br><span class="line">	       return max;</span><br><span class="line">	   &#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;测试用例：height[]&#123;1,8,6,2,5,4,8,3,7&#125;</span><br><span class="line">		int[] height &#x3D; new int[] &#123;1,8,6,2,5,4,8,3,7&#125;;</span><br><span class="line">		System.out.println(maxArea(height));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例：height[]{1,8,6,2,5,4,8,3,7}<br>测试结果：49<br>结果正确。</p>
<p><strong>LeetCode提交记录</strong></p>
<img src="/2020/07/20/LeetCode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8-%E6%95%B0%E7%BB%84-%E5%8F%8C%E6%8C%87%E9%92%88/result1.jpg" class title="提交记录">


<hr>
<p><strong>2.2. 优化解法</strong><br>我们知道，容器装水的体积的决定因素之一是<strong>容器左壁和右壁的长度较小者</strong>，所以我们在遍历所有左右壁组合的时候，<strong>固定长度较大的壁不动，将长度较小的壁向中间逼近</strong>。</p>
<p><strong>因为体积取决于长度较小的壁，所以我们暂且不管长度较长的壁，只是使长度较小的壁的长度尽可能地长，从而面积也尽可能地大，省去了许多无用步骤。</strong></p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MaxArea &#123;</span><br><span class="line">	public static int maxArea(int[] height) &#123;</span><br><span class="line">		int len &#x3D; height.length;</span><br><span class="line">        int max &#x3D; 0;</span><br><span class="line">        int left &#x3D; 0;</span><br><span class="line">        int right &#x3D; len - 1;</span><br><span class="line"></span><br><span class="line">        while(left &lt; right)&#123;</span><br><span class="line">            int area &#x3D; Math.min(height[left],height[right]) * (right - left);</span><br><span class="line">            max &#x3D; Math.max(max,area);</span><br><span class="line"></span><br><span class="line">            if(height[left] &gt; height[right])&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">	   &#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;测试用例：height[]&#123;1,8,6,2,5,4,8,3,7&#125;</span><br><span class="line">		int[] height &#x3D; new int[] &#123;1,8,6,2,5,4,8,3,7&#125;;</span><br><span class="line">		System.out.println(maxArea(height));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例：height[]{1,8,6,2,5,4,8,3,7}<br>测试结果：49<br>结果正确。</p>
<p><strong>LeetCode提交记录</strong></p>
<img src="/2020/07/20/LeetCode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8-%E6%95%B0%E7%BB%84-%E5%8F%8C%E6%8C%87%E9%92%88/result2.jpg" class title="提交记录">

<p>发现在运行时间上，较上一种暴力解法快了许多。</p>
<hr>
<p>如有错误，欢迎联系本人QQ：965299766</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 120.三角形最小路径和[数组][动态规划]</title>
    <url>/2020/07/16/LeetCode-120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C-%E6%95%B0%E7%BB%84-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="##1. 题目描述"></a>##1. 题目描述</h2><p><em>标签：[数组][动态规划]</em></p>
<p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<p>相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。</p>
<a id="more"></a>

<p><strong>例如，给定三角形：</strong></p>
<p>[<br>     [2],<br>    [3,4],<br>   [6,5,7],<br>  [4,1,8,3]<br>]</p>
<p>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p>
<hr>
<h2 id="2-题解"><a href="#2-题解" class="headerlink" title="##2. 题解"></a>##2. 题解</h2><p>仍然是一道经典的动态规划题，貌似我还在学校的OJ上做过^^，只是当时我还不知道啥是动态规划，也忘了当时咋做的了。</p>
<p><strong>①. 构建dp数组</strong><br>为了说明方便，我们将题目给定的三角形数组（triangle）列都一一对应好，这样看起来好看点，再创建一个规模和三角形数组一样的dp数组：</p>
<img src="/2020/07/16/LeetCode-120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C-%E6%95%B0%E7%BB%84-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.jpg" class title="图一">

<hr>
<p><strong>②. 这题的dp数组应该代表什么意思呢？</strong><br><strong>dp[i][j]代表：当从上至下走到这里的时候，我们可获得的最短路径。</strong><br>当然，前提是按规则走，且走到的地方，都必须有值（因为题目是三角形数组，而我们使用的是二维矩形数组，必然有右上方的部分格子没有值，我们不能走到没有值的地方去）。</p>
<hr>
<p><strong>③. 那我们是如何走的呢</strong><br><strong>那我们是如何走的呢？</strong><br>对于三角形数组，最上方的那一个格子，是我们的出发点，我们必须从出发点出发，所以对应dp数组的最上方那个格子的值，毫无疑问，就是三角形数组出发点的路径长度值。</p>
<img src="/2020/07/16/LeetCode-120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C-%E6%95%B0%E7%BB%84-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2.jpg" class title="图二">

<p>对于其他的格子，我们可以分为两种情况：<br><strong>3.1. 边缘格子</strong><br>什么是边缘格子呢，就像这样：</p>
<img src="/2020/07/16/LeetCode-120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C-%E6%95%B0%E7%BB%84-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/3.jpg" class title="图三">

<p>显然，边缘格子就是指处于三角形数组的边缘了，我们又可以分为左边缘格子和右边缘格子。<br>左边缘格子就是：除第一行外，每一行中列号为0的格子，也就是顶在数组最左边的那些格子；<br>右边缘格子就是：除第一行外，每一行中列号最大的格子，也就是顶在数组最右边的那些格子。</p>
<p><strong>我们如何走到一个左边缘格子？</strong><br>显然，要走到一个左边缘格子，我们首先必须得在上一行的左边缘格子上，才能保证下一步能走到这一行的左边缘格子。<br><strong>即，要想走到triangle[i][0]，我们首先必须得在triangle[i-1][0]的位置上。</strong></p>
<p><strong>dp数组也一样，即dp[i][0]=dp[i-1][0]+triangle[i][0]</strong></p>
<p><strong>我们如何走到一个右边缘格子？</strong><br>一样的，要走到一个右边缘格子，首先得处在上一行的右边缘格子上。<br><strong>也就是说，要想走到triangle[i][i]，首先我们得处于triangle[i-1][i-1]上。</strong></p>
<p><strong>dp数组也一样，即dp[i][i]=dp[i-1][i-1]+triangle[i][i]</strong></p>
<p><strong>3.2. 普通格子</strong><br>除了第一行的格子和边缘格子，其他的就叫普通格子了。</p>
<img src="/2020/07/16/LeetCode-120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C-%E6%95%B0%E7%BB%84-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/4.jpg" class title="图四">

<p><strong>我们如何走到一个普通格子上呢？</strong><br>根据规则，我们可以知道，从该格子的上一行同一列或者前一列的格子，可以走到该普通格子上，比如我们要走到5这个格子上：</p>
<img src="/2020/07/16/LeetCode-120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C-%E6%95%B0%E7%BB%84-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/5.jpg" class title="图五">

<p>我们只有处在3或4的位置上，才能让下一步走到5.</p>
<p>而dp数组要求的是最短路径，我们将这两种走法的路径最小值填入dp数组：<br><strong>即dp[i][j]=min(dp[i-1][j]+triangle[i][j],dp[i-1][j-1]+triangle[i][j])</strong></p>
<hr>
<p><strong>④. 此时，我们可以写出dp数组的递推公式了</strong></p>
<pre><code>dp[i][j] =    triangle[i][j]，当i=j=0时（第一格）
            dp[i-1][0]，当i!=0，j=0时（左边缘）
            dp[i-1][j-1]，当i!=0，j=i时（右边缘）
            min(dp[i-1][j]+triangle[i][j],dp[i-1][j-1]+triangle[i][j])，当i!=0，j!=i时（普通格）</code></pre><hr>
<p><strong>⑤. 获取答案</strong><br>dp数组填完后，如何获取最终的最短路径呢？<br>显然，走完后，答案必定在dp数组最后一行产生，我们只需要对dp数组最后一行进行排序，返回其中的最小值即可。</p>
<hr>
<h2 id="3-完整代码"><a href="#3-完整代码" class="headerlink" title="##3. 完整代码"></a>##3. 完整代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class MinimumTotal &#123;</span><br><span class="line">	public static int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;</span><br><span class="line">		int len&#x3D;triangle.size();&#x2F;&#x2F;len代表这个三角形共有几行</span><br><span class="line">		int[][] dp&#x3D;new int[len][len];&#x2F;&#x2F;动态规划数组，dp[i][j]代表走到第i行第j列时的最小路径长度</span><br><span class="line">		</span><br><span class="line">		for(int i&#x3D;0;i&lt;len;i++) &#123;</span><br><span class="line">			for(int j&#x3D;0;j&lt;i+1;j++) &#123;&#x2F;&#x2F;逐行逐个数判断</span><br><span class="line">				</span><br><span class="line">				if(i&#x3D;&#x3D;0&amp;&amp;j&#x3D;&#x3D;0) &#123;&#x2F;&#x2F;如果是第一行</span><br><span class="line">					dp[i][j]&#x3D;triangle.get(0).get(0);&#x2F;&#x2F;最小路径就是当前路径数组值</span><br><span class="line">				&#125;</span><br><span class="line">				else if(j&#x3D;&#x3D;0&amp;&amp;i!&#x3D;0) &#123;&#x2F;&#x2F;如果是第一列但不是第一行</span><br><span class="line">					dp[i][j]&#x3D;dp[i-1][j]+triangle.get(i).get(j);&#x2F;&#x2F;最小路径就是dp数组的上一行同列的值+路径数组当前值</span><br><span class="line">				&#125;</span><br><span class="line">				else if(j&#x3D;&#x3D;i&amp;&amp;i!&#x3D;0)&#123;&#x2F;&#x2F;如果是最后一列但不是第一行</span><br><span class="line">					dp[i][j]&#x3D;dp[i-1][j-1]+triangle.get(i).get(j);&#x2F;&#x2F;最小路径就是dp数组的上一行上一列的值+路径数组当前值</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;&#x2F;&#x2F;以上都不满足</span><br><span class="line">					dp[i][j]&#x3D;Math.min(dp[i-1][j]+triangle.get(i).get(j), dp[i-1][j-1]+triangle.get(i).get(j));&#x2F;&#x2F;最小路径就是两者的较小值</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Arrays.sort(dp[len-1]);&#x2F;&#x2F;对dp数组最后一行排序</span><br><span class="line">		return dp[len-1][0];&#x2F;&#x2F;返回dp数组最后一行的最小值即为答案</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;*测试用例：[2],</span><br><span class="line">	    *						[3,4],</span><br><span class="line">	    *						[6,5,7],</span><br><span class="line">	   *						[4,1,8,3]</span><br><span class="line">	   *&#x2F;</span><br><span class="line">		List&lt;List&lt;Integer&gt;&gt; triangle&#x3D;new ArrayList&lt;List&lt;Integer&gt;&gt;() ;</span><br><span class="line">		</span><br><span class="line">		List&lt;Integer&gt; one&#x3D;new ArrayList&lt;Integer&gt;() ;</span><br><span class="line">		one.add(2);</span><br><span class="line">		triangle.add(one);</span><br><span class="line">		</span><br><span class="line">		List&lt;Integer&gt; two&#x3D;new ArrayList&lt;Integer&gt;();</span><br><span class="line">		two.add(3);</span><br><span class="line">		two.add(4);</span><br><span class="line">		triangle.add(two);</span><br><span class="line">		</span><br><span class="line">		List&lt;Integer&gt; three&#x3D;new ArrayList&lt;Integer&gt;();</span><br><span class="line">		three.add(6);</span><br><span class="line">		three.add(5);</span><br><span class="line">		three.add(7);</span><br><span class="line">		triangle.add(three);</span><br><span class="line">		</span><br><span class="line">		List&lt;Integer&gt; four&#x3D;new ArrayList&lt;Integer&gt;();</span><br><span class="line">		four.add(4);</span><br><span class="line">		four.add(1);</span><br><span class="line">		four.add(8);</span><br><span class="line">		four.add(3);</span><br><span class="line">		triangle.add(four);</span><br><span class="line">		</span><br><span class="line">		int ans&#x3D;minimumTotal(triangle);</span><br><span class="line">		System.out.println(ans);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例：<br>[2],<br>[3,4],<br>[6,5,7],<br>[4,1,8,3]</p>
<p>测试结果：最短路径=11<br>结果正确。</p>
<p><strong>LeetCode提交记录</strong></p>
<img src="/2020/07/16/LeetCode-120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C-%E6%95%B0%E7%BB%84-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/result.jpg" class title="提交记录">

<hr>
<p>如有错误，欢迎联系本人QQ：965299766</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 146.LRU缓存机制[设计]</title>
    <url>/2020/07/12/LeetCode-146-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6-%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="##1. 题目描述"></a>##1. 题目描述</h2><p><em>标签：[设计][哈希表][队列]</em></p>
<p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p>
<p>获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p>
<a id="more"></a>


<p><strong>示例:</strong></p>
<p>LRUCache cache = new LRUCache(2);    //缓存容量为2</p>
<p>cache.put(1, 1);<br>cache.put(2, 2);<br>cache.get(1);       // 返回  1<br>cache.put(3, 3);    // 该操作会使得关键字 2 作废<br>cache.get(2);       // 返回 -1 (未找到)<br>cache.put(4, 4);    // 该操作会使得关键字 1 作废<br>cache.get(1);       // 返回 -1 (未找到)<br>cache.get(3);       // 返回  3<br>cache.get(4);       // 返回  4</p>
<hr>
<h2 id="2-题解"><a href="#2-题解" class="headerlink" title="##2. 题解"></a>##2. 题解</h2><p>我们在上操作系统这门课的时候就接触过LRU缓存机制（最近最少使用），应该是使用到类似于队列的数据结构，所以本题我决定使用队列的方法来解决。<br>而由于题目告诉我们，数据是以关键字-值的形式，即key-value的形式储存，我们自然可以想到储存这样的数据应该使用Map接口，这题我使用的是HashMap类。</p>
<p><strong>①. 初始化</strong><br>由于构造函数传入了一个参数capacity，代表缓存的容量，所以我们需要在类中定义一个参数来接收传入的capacity。定义变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; hash;&#x2F;&#x2F;键-值对应哈希表</span><br><span class="line">int capacity;&#x2F;&#x2F;容量</span><br><span class="line">Queue&lt;Integer&gt; queue;&#x2F;&#x2F;队列</span><br></pre></td></tr></table></figure>
<p>构造函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public LRUCache(int capacity) &#123;</span><br><span class="line">	&#x2F;&#x2F;构造函数初始化，创建队列和哈希表对象，将容量赋值为函数传入的capacity值</span><br><span class="line">	queue&#x3D;new LinkedList &lt;Integer&gt; () ;</span><br><span class="line">	hash&#x3D;new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">	this.capacity&#x3D;capacity;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>②. 完成put()函数</strong><br>put(key,value)函数的要求是传入一个关键字和值，判断关键字是否已存在，如果存在，更改其值为value；否则，插入该组[关键字/值]到缓存。如果缓存容量到达上限，应删除最久未使用的数据。<br>1）如果缓存中没找到该关键字，我们就要在缓存中插入该组数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(queue.isEmpty()||!queue.contains(key)) &#123;&#x2F;&#x2F;如果队列为空或者不包含当前插入的关键字</span><br><span class="line">   		queue.offer(key);&#x2F;&#x2F;将关键字加入队列</span><br><span class="line">   		hash.put(key, value);&#x2F;&#x2F;将值插入哈希表中</span><br><span class="line">   		if(queue.size()&gt;capacity) &#123;&#x2F;&#x2F;如果此时队列容量满</span><br><span class="line">   			queue.poll();&#x2F;&#x2F;删除最久未使用的关键字</span><br><span class="line">   		&#125;</span><br><span class="line">   	&#125;</span><br></pre></td></tr></table></figure>
<p>我们暂且认为每次操作后，队列都会按照最近使用的先后顺序进行排序（接下来会讲怎么实现），所以上面代码中的 queue.poll() 函数删除的必定是最久未使用的关键字。</p>
<p>2）如果缓存中找到了该关键字，我们就需要修改该关键字对应的值为value，并且把队列中该关键字放到队尾（代表最近被使用）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">else &#123;&#x2F;&#x2F;如果已包含当前关键字</span><br><span class="line">   		queue&#x3D;repair(key,value);&#x2F;&#x2F;修改该关键字在队列中的优先级，修改哈希表中该关键字对应的值</span><br><span class="line">   	&#125;</span><br></pre></td></tr></table></figure>

<p>3）其中我写了个repair(key,value)函数，用来修改key在队列中的优先级，并且修改哈希表中key对应的值为value：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Queue&lt;Integer&gt; repair(int key,int value) &#123;</span><br><span class="line">	&#x2F;&#x2F;修改队列优先级和哈希表的键值</span><br><span class="line">	Queue&lt;Integer&gt; q&#x3D;new LinkedList&lt;Integer&gt;();</span><br><span class="line">	for(int k:queue) &#123;</span><br><span class="line">		if(k&#x3D;&#x3D;key) </span><br><span class="line">			continue;</span><br><span class="line">		else &#123;</span><br><span class="line">			q.offer(k);&#x2F;&#x2F;将队列中不等于关键字的元素按原序放入一个新的队列中</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	q.offer(key);&#x2F;&#x2F;最后在新队列中放入关键字元素，代表该关键字在队列中是最近被使用的，优先级最高</span><br><span class="line">	hash.put(key, value);&#x2F;&#x2F;更新哈希表中对应的键值</span><br><span class="line">	return q;&#x2F;&#x2F;返回新队列</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：这里的repair函数比较重要，在后面还会使用到。</p>
<p><strong>③. 完成get()函数</strong><br>1）get(key)的作用是，如果在缓存中找不到该关键字key，返回-1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;如果队列是空的或者找不到该关键字，返回-1</span><br><span class="line">if(queue.isEmpty()||!queue.contains(key)) &#123;</span><br><span class="line">	return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）如果找到了关键字，我们只需要将队列中该关键字key放置到队尾（最近被使用）即可，key对应的value不必改变，如果需要使用上面我们已完成的repair函数，我们只需传入key和key对应的value即可，代表将key对应的值value修改为原来值，即不作改变。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;不然，找到了该关键字的话，修改该关键字在队列中的优先级，并返回哈希表中该关键字对应的值</span><br><span class="line">queue&#x3D;repair(key,hash.get(key));</span><br><span class="line">return hash.get(key);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-完整代码"><a href="#3-完整代码" class="headerlink" title="##3. 完整代码"></a>##3. 完整代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Queue;</span><br><span class="line"></span><br><span class="line">public class LRUCache &#123;</span><br><span class="line">	</span><br><span class="line">	Map&lt;Integer, Integer&gt; hash;&#x2F;&#x2F;键-值对应哈希表</span><br><span class="line">	int capacity;&#x2F;&#x2F;容量</span><br><span class="line">	Queue&lt;Integer&gt; queue;&#x2F;&#x2F;队列</span><br><span class="line">	</span><br><span class="line">	public LRUCache(int capacity) &#123;</span><br><span class="line">		&#x2F;&#x2F;构造函数初始化，创建队列和哈希表对象，将容量赋值为函数传入的capacity值</span><br><span class="line">		queue&#x3D;new LinkedList &lt;Integer&gt; () ;</span><br><span class="line">		hash&#x3D;new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">		this.capacity&#x3D;capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int get(int key) &#123;</span><br><span class="line">    	&#x2F;&#x2F;如果队列是空的或者找不到该关键字，返回-1</span><br><span class="line">    	if(queue.isEmpty()||!queue.contains(key)) &#123;</span><br><span class="line">    		return -1;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	&#x2F;&#x2F;不然，找到了该关键字的话，修改该关键字在队列中的优先级，并返回哈希表中该关键字对应的值</span><br><span class="line">    	queue&#x3D;repair(key,hash.get(key));</span><br><span class="line">    	return hash.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void put(int key, int value) &#123;</span><br><span class="line">    	</span><br><span class="line">    	if(queue.isEmpty()||!queue.contains(key)) &#123;&#x2F;&#x2F;如果队列为空或者不包含当前插入的关键字</span><br><span class="line">    		queue.offer(key);&#x2F;&#x2F;将关键字加入队列</span><br><span class="line">    		hash.put(key, value);&#x2F;&#x2F;将值插入哈希表中</span><br><span class="line">    		if(queue.size()&gt;capacity) &#123;&#x2F;&#x2F;如果此时队列容量满</span><br><span class="line">    			queue.poll();&#x2F;&#x2F;删除最久未使用的关键字</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;else &#123;&#x2F;&#x2F;如果已包含当前关键字</span><br><span class="line">    		queue&#x3D;repair(key,value);&#x2F;&#x2F;修改该关键字在队列中的优先级，修改哈希表中该关键字对应的值</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	private Queue&lt;Integer&gt; repair(int key,int value) &#123;</span><br><span class="line">		&#x2F;&#x2F;修改队列优先级和哈希表的键值</span><br><span class="line">		Queue&lt;Integer&gt; q&#x3D;new LinkedList&lt;Integer&gt;();</span><br><span class="line">		for(int k:queue) &#123;</span><br><span class="line">			if(k&#x3D;&#x3D;key) </span><br><span class="line">				continue;</span><br><span class="line">			else &#123;</span><br><span class="line">				q.offer(k);&#x2F;&#x2F;将队列中不等于关键字的元素按原序放入一个新的队列中</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		q.offer(key);&#x2F;&#x2F;最后在新队列中放入关键字元素，代表该关键字在队列中是最近被使用的，优先级最高</span><br><span class="line">		hash.put(key, value);&#x2F;&#x2F;更新哈希表中对应的键值</span><br><span class="line">		return q;&#x2F;&#x2F;返回新队列</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;测试用例</span><br><span class="line">		LRUCache cache&#x3D;new LRUCache(2);</span><br><span class="line">		int ans&#x3D;0;</span><br><span class="line">		cache.put(1, 1);</span><br><span class="line">		cache.put(2, 2);</span><br><span class="line">		ans&#x3D;cache.get(1);       &#x2F;&#x2F; 返回  1</span><br><span class="line">		System.out.println(ans);</span><br><span class="line">		cache.put(3, 3);    &#x2F;&#x2F; 该操作会使得关键字 2 作废</span><br><span class="line">		ans&#x3D;cache.get(2);       &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">		System.out.println(ans);</span><br><span class="line">		cache.put(4, 4);    &#x2F;&#x2F; 该操作会使得关键字 1 作废</span><br><span class="line">		ans&#x3D;cache.get(1);       &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">		System.out.println(ans);</span><br><span class="line">		ans&#x3D;cache.get(3);       &#x2F;&#x2F; 返回  3</span><br><span class="line">		System.out.println(ans);</span><br><span class="line">		ans&#x3D;cache.get(4);       &#x2F;&#x2F; 返回  4</span><br><span class="line">		System.out.println(ans);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例：<br>new LRUCache(2);<br>put(1,1);<br>put(1,2);<br>get(1);<br>put(3,3);<br>get(2);<br>put(4,4);<br>get(1);<br>get(3);<br>get(4);</p>
<p>测试结果：<br>null<br>null<br>null<br>1<br>null<br>-1<br>null<br>-1<br>3<br>4</p>
<p>结果正确。</p>
<p><strong>LeetCode提交记录</strong></p>
<img src="/2020/07/12/LeetCode-146-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6-%E8%AE%BE%E8%AE%A1/result.jpg" class title="提交记录">

<hr>
<p>如有错误，欢迎联系本人QQ：965299766</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>哈希表</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 155.最小栈[栈][设计]</title>
    <url>/2020/07/05/LeetCode-155-%E6%9C%80%E5%B0%8F%E6%A0%88-%E6%A0%88-%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="##1. 题目描述"></a>##1. 题目描述</h2><p><em>标签：[栈][设计]</em></p>
<p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<pre><code>push(x) —— 将元素 x 推入栈中。
pop() —— 删除栈顶的元素。
top() —— 获取栈顶元素。
getMin() —— 检索栈中的最小元素。</code></pre><a id="more"></a>

<p><strong>示例:</strong></p>
<p><strong>输入：</strong><br>[“MinStack”,”push”,”push”,”push”,”getMin”,”pop”,”top”,”getMin”]<br>[[],[-2],[0],[-3],[],[],[],[]]</p>
<p><strong>输出：</strong><br>[null,null,null,null,-3,null,0,-2]</p>
<p><strong>解释：</strong><br>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   –&gt; 返回 -2.</p>
<p><strong>提示：</strong><br>pop、top 和 getMin 操作总是在 非空栈 上调用。</p>
<hr>
<h2 id="2-题解"><a href="#2-题解" class="headerlink" title="##2. 题解"></a>##2. 题解</h2><p>本题是一道设计题，已经提前给出了模板，要求我们对其中给出的函数进行完善，以达到他的要求。</p>
<img src="/2020/07/05/LeetCode-155-%E6%9C%80%E5%B0%8F%E6%A0%88-%E6%A0%88-%E8%AE%BE%E8%AE%A1/model.jpg" class title="模板">

<p>要求是能够实现栈最基本的push、pop和top操作的同时，还需要实现获取栈中最小值getMin的功能。</p>
<p>相信上过数据结构课的各位做这题应该不难（doge），在C++中，我们使用动态数组来实现栈的各种功能，在Java中，我们依然使用动态数组ArrayList来实现。<br>题目不难，直接放代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class MinStack &#123;</span><br><span class="line">	private ArrayList&lt;Integer&gt; array;</span><br><span class="line">	</span><br><span class="line">	public MinStack() &#123;</span><br><span class="line">		array&#x3D;new ArrayList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">    	array.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void pop() &#123;</span><br><span class="line">    	if(!array.isEmpty()) &#123;</span><br><span class="line">    		array.remove(array.size()-1);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int top() &#123;</span><br><span class="line">    	if(!array.isEmpty())</span><br><span class="line">    		return array.get(array.size()-1);</span><br><span class="line">    	else</span><br><span class="line">    		return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int getMin() &#123;</span><br><span class="line">    	if(!array.isEmpty()) &#123;</span><br><span class="line">	    	int min&#x3D;Integer.MAX_VALUE;</span><br><span class="line">	    	for(int i&#x3D;0;i&lt;array.size();i++) &#123;</span><br><span class="line">	    		if(array.get(i)&lt;min)</span><br><span class="line">	    			min&#x3D;array.get(i);</span><br><span class="line">	    	&#125;</span><br><span class="line">			return min;</span><br><span class="line">    	&#125;</span><br><span class="line">    	else</span><br><span class="line">    		return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;测试用例</span><br><span class="line">		MinStack minStack&#x3D;new MinStack();</span><br><span class="line">		minStack.push(-2);</span><br><span class="line">		minStack.push(0);</span><br><span class="line">		minStack.push(-3);</span><br><span class="line">		System.out.println(minStack.getMin());</span><br><span class="line">		minStack.pop();</span><br><span class="line">		System.out.println(minStack.top());</span><br><span class="line">		System.out.println(minStack.getMin());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例：</p>
<pre><code>操作：[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]
输入：[[],[-2],[0],[-3],[],[],[],[]]</code></pre><p>输出：</p>
<img src="/2020/07/05/LeetCode-155-%E6%9C%80%E5%B0%8F%E6%A0%88-%E6%A0%88-%E8%AE%BE%E8%AE%A1/run.jpg" class title="运行">

<p>可以看到我们向栈中push了三个数字-2,0,-3，然后输出栈中最小值为-3，然后删除了栈顶元素，输出了现在的栈顶元素0，然后输出了现在的最小值为-2，结果正确。</p>
<p><strong>LeetCode提交结果：</strong></p>
<img src="/2020/07/05/LeetCode-155-%E6%9C%80%E5%B0%8F%E6%A0%88-%E6%A0%88-%E8%AE%BE%E8%AE%A1/result1.jpg" class title="提交结果">

<hr>
<p>如有错误，欢迎联系本人QQ：965299766</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 169.多数元素[数组]</title>
    <url>/2020/07/06/LeetCode-169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="##1. 题目描述"></a>##1. 题目描述</h2><p><em>标签：[数组]</em></p>
<p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<a id="more"></a>


<p><strong>示例 1:</strong></p>
<p>输入: [3,2,3]<br>输出: 3</p>
<p><strong>示例 2:</strong></p>
<p>输入: [2,2,1,1,1,2,2]<br>输出: 2</p>
<hr>
<h2 id="2-题解"><a href="#2-题解" class="headerlink" title="##2. 题解"></a>##2. 题解</h2><p><strong>###2.1. 思路</strong><br>要求一个大小为n的数组中，出现次数大于n/2的元素，我们可以直接把数组进行排序，因为要求的数出现次数大于数组长度的一半，所以我们可以直接认为排序后的数组的中间那个数就是我们要求的数。</p>
<p><strong>###2.2. 代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class MajorityElement &#123;</span><br><span class="line">	public static int majorityElement(int[] nums) &#123;</span><br><span class="line">		if(nums.length&#x3D;&#x3D;1)&#x2F;&#x2F;如果数组只有一个元素，返回他</span><br><span class="line">			return nums[0];</span><br><span class="line">		</span><br><span class="line">		Arrays.sort(nums);&#x2F;&#x2F;排序</span><br><span class="line">		return nums[nums.length&#x2F;2];&#x2F;&#x2F;直接返回中位数</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int[] nums&#x3D;new int[] &#123;2,2,1,1,1,2,2&#125;;</span><br><span class="line">		int ans&#x3D;majorityElement(nums);</span><br><span class="line">		System.out.println(ans);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例：数组nums={2,2,1,1,1,2,2}<br>测试结果：2<br>结果正确</p>
<p><strong>###2.3. LeetCode提交记录</strong></p>
<img src="/2020/07/06/LeetCode-169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0-%E6%95%B0%E7%BB%84/result.jpg" class title="提交记录">

<hr>
<p>如有错误，欢迎联系本人QQ：965299766</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 174.地下城游戏[动态规划]</title>
    <url>/2020/07/12/LeetCode-174-%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="##1. 题目描述"></a>##1. 题目描述</h2><p><em>标签：[动态规划]</em></p>
<p>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p>
<p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p>
<p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</p>
<p>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p>
<p>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。</p>
<a id="more"></a>

<p>例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -&gt; 右 -&gt; 下 -&gt; 下，则骑士的初始健康点数至少为 7。</p>
<img src="/2020/07/12/LeetCode-174-%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/map.jpg" class title="地图">


<p>说明:</p>
<pre><code>骑士的健康点数没有上限。
任何房间都可能对骑士的健康点数造成威胁，
也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</code></pre><hr>
<h2 id="2-题解"><a href="#2-题解" class="headerlink" title="##2. 题解"></a>##2. 题解</h2><p>这道题虽然在力扣上是困难标签，但实际上是一道中规中矩的动态规划题，只是看能不能想到怎么构建动态规划数组，想到就比较容易，想不到就感觉无从下手（比如我）。</p>
<p>①. 构造一个规模与给定的地下城地图规模一样大的动态规划数组dp[][]，<strong>dp[i][j]代表：骑士如果想走到这个房间前，他至少得有多少健康点数，才能保证他走入这个房间后，不会因为扣血至零而死，dp[i][j]记录的是走入该房间前至少需要的健康点数。</strong><br>注意：如果该房间是给骑士加血的，我们仍要保证骑士能够活着走入该房间，也就是说进入该房间前，他至少得拥有1点健康点数，<strong>也就是说，dp[i][j]的值必须是大于0的数，若程序计算过程中，dp[i][j]值小于1了，我们需要把他变为1。</strong></p>
<p>②. 我们就拿题目给的例子来举例吧，由于骑士一开始在左上角，公主在右下角，而骑士只能往右或下走，所以我们构造dp数组时，从右下往左上构造。<br><strong>1）看最右下角，进入该房间骑士会扣除5点健康点数，所以进入该房间前，骑士至少得有6点健康点数，才能保证他进入后，能够留下1点来存活下来，所以dp最右下角填6；</strong></p>
<img src="/2020/07/12/LeetCode-174-%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.jpg" class title="图一">

<p><strong>2）我们已经知道了进入最后一间房间前需要的最小健康点数，那骑士是如何进入该房间的呢，根据题意，骑士只会从该房间的上方或左方进入</strong>。<br>2.1）先看骑士走上方这条路的情况，我们从地图看出，上方这间房间，进入后会给骑士回复1点健康点数，我们已知进入终点房间前至少需要6点，而终点上面那个房间又会给骑士回复1点，所以骑士进入上方那个房间前至少需要(6-1)=5点健康点数；</p>
<p>2.2）再看骑士走左方这条路的情况，从地图得知，左方这个房间，进入后会回复30点健康点数，同样地，我们使用(6-30)=-24得到进入左方房间前需要的最小点数，但实际上进入前点数为-24的话，骑士早就挂了，也就是最小点数不能小于1，所以我们直接将该房间进入前的最小点数置为1；</p>
<img src="/2020/07/12/LeetCode-174-%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2.jpg" class title="图二">

<p><strong>3）用同样的方法，我们填完dp数组的最后一行和最后一列，结果是这样的</strong></p>
<img src="/2020/07/12/LeetCode-174-%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/3.jpg" class title="图三">

<p><strong>4）这时候我们看dp数组中间这个格子，看他的右方和下方的数值是否已经确定，因为从这个格子出发，骑士只能走到右方或下方的格子，我们必须知道右方和下方格子进入前的最小点数要求，我们才能计算出中间这个格子的最小点数要求。</strong><br>看地图数组，我们发现中间这个格子进入后会扣10点健康点数，我们再看dp数组，如果从中间这个格子往右走，我们至少需要5点点数，如果往下走，我们至少需要1点点数，我们直接挑较小的那一个数对应的房间，作为骑士接下来要进入的房间，此时可以得到进入中间这个房间前，骑士至少得有(1-(-10))=11点健康点数。</p>
<img src="/2020/07/12/LeetCode-174-%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/4.jpg" class title="图四">

<p><strong>5）接下来用同样的方法，填完dp数组即可</strong></p>
<img src="/2020/07/12/LeetCode-174-%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/5.jpg" class title="图五">

<p><strong>显然，dp[0][0]就是我们最后要找的答案。</strong></p>
<hr>
<h2 id="3-完整代码"><a href="#3-完整代码" class="headerlink" title="##3. 完整代码"></a>##3. 完整代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CalculateMinimumHP &#123;</span><br><span class="line">	public static int calculateMinimumHP(int[][] dungeon) &#123;</span><br><span class="line">		int row&#x3D;dungeon.length;&#x2F;&#x2F;行</span><br><span class="line">		int col&#x3D;dungeon[0].length;&#x2F;&#x2F;列</span><br><span class="line">		int[][] dp&#x3D;new int[row][col];&#x2F;&#x2F;dp数组</span><br><span class="line">		</span><br><span class="line">		for(int i&#x3D;row-1;i&gt;&#x3D;0;i--) &#123;</span><br><span class="line">			for(int j&#x3D;col-1;j&gt;&#x3D;0;j--) &#123;&#x2F;&#x2F;从右下往左上</span><br><span class="line">				</span><br><span class="line">				if(i&#x3D;&#x3D;row-1&amp;&amp;j&#x3D;&#x3D;col-1) &#123;	&#x2F;&#x2F;如果是最右下那个房间</span><br><span class="line">					dp[i][j]&#x3D;1-dungeon[i][j];	&#x2F;&#x2F;最低生命值为1，减掉房间扣除的，就是进入前应该有的最低健康点数</span><br><span class="line">					if(dp[i][j]&lt;&#x3D;0)	&#x2F;&#x2F;判断如果减了之后小于1了</span><br><span class="line">						dp[i][j]&#x3D;1;	&#x2F;&#x2F;强行改为1</span><br><span class="line">				&#125;</span><br><span class="line">				else if(i&#x3D;&#x3D;row-1) &#123;	&#x2F;&#x2F;填完最后一行</span><br><span class="line">					dp[i][j]&#x3D;dp[i][j+1]-dungeon[i][j];</span><br><span class="line">					if(dp[i][j]&lt;&#x3D;0)</span><br><span class="line">						dp[i][j]&#x3D;1;</span><br><span class="line">				&#125;</span><br><span class="line">				else if(j&#x3D;&#x3D;col-1) &#123;	&#x2F;&#x2F;填完最后一列</span><br><span class="line">					dp[i][j]&#x3D;dp[i+1][j]-dungeon[i][j];</span><br><span class="line">					if(dp[i][j]&lt;&#x3D;0)</span><br><span class="line">						dp[i][j]&#x3D;1;</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;	&#x2F;&#x2F;填完其他格子</span><br><span class="line">					dp[i][j]&#x3D;(dp[i+1][j]-dungeon[i][j]&gt;dp[i][j+1]-dungeon[i][j])?dp[i][j+1]-dungeon[i][j]:dp[i+1][j]-dungeon[i][j];</span><br><span class="line">					if(dp[i][j]&lt;&#x3D;0)</span><br><span class="line">						dp[i][j]&#x3D;1;</span><br><span class="line">				&#125;</span><br><span class="line">						</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		return dp[0][0];	&#x2F;&#x2F;返回答案</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;*测试用例：地下城地图数组：</span><br><span class="line">		 * -2(K) -3 3</span><br><span class="line">		 * -5 -10 1</span><br><span class="line">		 * 10 30 -5(P)</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		int[][] dungeon&#x3D;new int[][] &#123;&#123;-2,-3,3&#125;,&#123;-5,-10,1&#125;,&#123;10,30,-5&#125;&#125;;</span><br><span class="line">		int ans&#x3D;calculateMinimumHP(dungeon);</span><br><span class="line">		System.out.println(ans);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例：地下城地图：</p>
<img src="/2020/07/12/LeetCode-174-%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/map.jpg" class title="地图">

<p>测试结果：进入地下城前骑士应具有的最低健康点数：7<br>结果正确。</p>
<p><strong>LeetCode提交记录</strong></p>
<img src="/2020/07/12/LeetCode-174-%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/result.jpg" class title="提交记录">

<hr>
<p>如有错误，欢迎联系本人QQ：965299766</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 19.删除链表的倒数第N个节点[链表][双指针]</title>
    <url>/2020/07/23/LeetCode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9-%E9%93%BE%E8%A1%A8-%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="##1. 题目描述"></a>##1. 题目描述</h2><p><em>标签：[链表][双指针]</em></p>
<p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
<p><strong>示例：</strong></p>
<p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</p>
<p>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</p>
<p><strong>说明：</strong></p>
<p>给定的 n 保证是有效的。</p>
<a id="more"></a>

<hr>
<h2 id="2-题解"><a href="#2-题解" class="headerlink" title="##2. 题解"></a>##2. 题解</h2><p><strong>2.1. 常规解法</strong><br>看到这题最容易想到的解法就是遍历两次链表。<br><strong>第一次遍历可以获取到链表的长度len。</strong><br><strong>第二次遍历，当遍历到第 (len - n) 个结点时，删除该结点的下一结点。最后返回head即可。</strong></p>
<hr>
<p><strong>2.2. 双指针解法</strong><br>题目告知我们n必定是有效的，不会出现<strong>n大于链表长度</strong>的情况。<br>我们可以采用<strong>双指针</strong>的方法来解决本问题。</p>
<p><strong>①. 定义两个指针p和q，同时指向head结点；</strong></p>
<img src="/2020/07/23/LeetCode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9-%E9%93%BE%E8%A1%A8-%E5%8F%8C%E6%8C%87%E9%92%88/1.jpg" class title="图一">

<p><strong>②. 让p指针先往后移动n个结点，q指针不动；</strong></p>
<img src="/2020/07/23/LeetCode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9-%E9%93%BE%E8%A1%A8-%E5%8F%8C%E6%8C%87%E9%92%88/2.jpg" class title="图二">

<p><strong>③. 然后p，q指针同时向后移动，直到p指针的下一结点为null时停止；</strong></p>
<img src="/2020/07/23/LeetCode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9-%E9%93%BE%E8%A1%A8-%E5%8F%8C%E6%8C%87%E9%92%88/3.jpg" class title="图三">

<p><strong>④. 此时发现q的下一结点正是我们要删除的结点；</strong></p>
<img src="/2020/07/23/LeetCode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9-%E9%93%BE%E8%A1%A8-%E5%8F%8C%E6%8C%87%E9%92%88/4.jpg" class title="图四">

<p><strong>⑤. 删除成功后返回head结点作为答案。</strong></p>
<hr>
<p><strong>2.3. 存在的问题</strong><br>这种方法在极端情况下有潜在的问题：</p>
<p><strong>当我们要删除的结点正好是head结点</strong>时，怎么办？</p>
<p>举个例子：<br>给定链表 = [1,2]，n = 2，</p>
<p><strong>p结点从head结点出发，移动n = 2位后，已经指向了null了，此时我们无法判断null的下一结点是不是null，就会报找不到指针的错误。</strong></p>
<hr>
<p><strong>2.4. 解决方案</strong><br>解决方法也很简单，<br><strong>设置一个 “哑结点” d，他指向的下一个结点是head结点，此时就不会出现上述错误。</strong></p>
<p><strong>①. 设置“哑结点”d，他的下一个结点指向的是head；</strong></p>
<img src="/2020/07/23/LeetCode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9-%E9%93%BE%E8%A1%A8-%E5%8F%8C%E6%8C%87%E9%92%88/5.jpg" class title="图五">

<p><strong>②. p结点向后移动n位；</strong></p>
<img src="/2020/07/23/LeetCode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9-%E9%93%BE%E8%A1%A8-%E5%8F%8C%E6%8C%87%E9%92%88/6.jpg" class title="图六">

<p><strong>③. p，q结点同时移动，直到p结点的下一结点为null；</strong></p>
<img src="/2020/07/23/LeetCode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9-%E9%93%BE%E8%A1%A8-%E5%8F%8C%E6%8C%87%E9%92%88/7.jpg" class title="图七">

<p><strong>④. 删除q结点的下一结点，也就是head结点；</strong></p>
<img src="/2020/07/23/LeetCode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9-%E9%93%BE%E8%A1%A8-%E5%8F%8C%E6%8C%87%E9%92%88/8.jpg" class title="图八">

<p><strong>⑤. 注意：此时返回的答案就不是哑结点d了，而是d.next。</strong></p>
<hr>
<h2 id="3-具体代码"><a href="#3-具体代码" class="headerlink" title="##3. 具体代码"></a>##3. 具体代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode removeNthFromEnd(ListNode head, int n) &#123;</span><br><span class="line">        ListNode d &#x3D; new ListNode(0);</span><br><span class="line">        d.next &#x3D; head;&#x2F;&#x2F;哑结点d</span><br><span class="line"></span><br><span class="line">        ListNode p &#x3D; d;</span><br><span class="line">        ListNode q &#x3D; null;</span><br><span class="line"></span><br><span class="line">        while(n !&#x3D; 0)&#123;&#x2F;&#x2F;p向后移动n位</span><br><span class="line">            p &#x3D; p.next;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        q &#x3D; d;</span><br><span class="line">        while(p.next !&#x3D; null)&#123;&#x2F;&#x2F;p，q同时移动直到p的下一结点为null</span><br><span class="line">            p &#x3D; p.next;</span><br><span class="line">            q &#x3D; q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        q.next &#x3D; q.next.next;&#x2F;&#x2F;删除q的下一结点</span><br><span class="line">        return d.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例：链表 = 1-&gt;2-&gt;3-&gt;4-&gt;5，n = 2<br>测试结果：1-&gt;2-&gt;3-&gt;5<br>结果正确。</p>
<p><strong>LeetCode提交记录</strong></p>
<img src="/2020/07/23/LeetCode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9-%E9%93%BE%E8%A1%A8-%E5%8F%8C%E6%8C%87%E9%92%88/result.jpg" class title="提交记录">

<hr>
<p>如有错误，欢迎联系本人QQ：965299766</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 198.打家劫舍[动态规划]</title>
    <url>/2020/07/05/LeetCode-198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="##1. 题目描述"></a>##1. 题目描述</h2><p><em>标签：[动态规划]</em></p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<a id="more"></a>


<p><strong>示例 1：</strong></p>
<p>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>     偷窃到的最高金额 = 1 + 3 = 4 。</p>
<p><strong>示例 2：</strong></p>
<p>输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p>
<p><strong>提示：</strong></p>
<pre><code>0 &lt;= nums.length &lt;= 100
0 &lt;= nums[i] &lt;= 400</code></pre><hr>
<h2 id="2-题解"><a href="#2-题解" class="headerlink" title="##2. 题解"></a>##2. 题解</h2><p>这道题显然可以使用动态规划来解决，是动态规划的经典题型。<br>①. 当房屋数组元素个数为0时，显然无房屋可偷，直接返回0；<br>②. 当有1个房屋时，该房屋的价值显然就是最大价值，返回他即可；<br>③. 当有2个房屋时，由题意可得，我们不能同时偷窃两个相邻的房屋，显然，我们只能偷这两个房屋中价值较大的那个，所以应返回两房屋价值的较大者；<br>④. 当偷到2个以上房屋时，我们就要考虑两种情况了，假设目前正准备偷第k间房屋（k&gt;2），我们会面临两个选择：<br>    1）偷第k间房屋，因为和第k-1间房间相邻，我们就不能偷第k-1间房屋，那此时我们可获得的总价值为前面已经做过选择的k-2间房屋的最大价值加上第k间房屋的价值；<br>    2）不偷第k间房屋，那第k-1间房屋就是可以偷窃的，那此时我们获得的总价值就是前面已做过选择的k-1间房屋的最大价值。<br>从2个选择中选择能获得价值较大的一项，将该价值作为处理这间房屋所获得的最大价值。<br>⑤. 对于每间房屋，都按照④的方法进行选择，对每间房屋都可以求出偷窃到该房屋时能获得的最大价值，放在dp数组中的对应位置；<br>⑥. 最后返回dp数组的最后一项，因为执行以上算法后，即对最后一间房屋做出选择后，获得的价值就是你能获得的最大价值了。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Rob &#123;</span><br><span class="line">	public static int rob(int[] nums) &#123;</span><br><span class="line">		if(nums.length&#x3D;&#x3D;0)</span><br><span class="line">			return 0;</span><br><span class="line">		if(nums.length&#x3D;&#x3D;1)</span><br><span class="line">			return nums[0];</span><br><span class="line">		if(nums.length&#x3D;&#x3D;2)</span><br><span class="line">			return nums[0]&gt;nums[1]?nums[0]:nums[1];</span><br><span class="line">		</span><br><span class="line">		int[] dp&#x3D;new int[nums.length];</span><br><span class="line">		dp[0]&#x3D;nums[0];</span><br><span class="line">		dp[1]&#x3D;nums[0]&gt;nums[1]?nums[0]:nums[1];</span><br><span class="line">		for(int i&#x3D;2;i&lt;nums.length;i++) &#123;</span><br><span class="line">			dp[i]&#x3D;dp[i-2]+nums[i]&gt;dp[i-1]?dp[i-2]+nums[i]:dp[i-1];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		return dp[dp.length-1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;测试用例：各房子的价值&#x3D;&#123;2,7,9,3,1&#125;</span><br><span class="line">		int[] nums&#x3D;new int[] &#123;2,7,9,3,1&#125;;</span><br><span class="line">		int ans&#x3D;rob(nums);</span><br><span class="line">		System.out.println(ans);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例：房子的价值数组={2,7,9,3,1}<br>测试结果：最大价值=12</p>
<hr>
<p><strong>LeetCode提交记录：</strong></p>
<img src="/2020/07/05/LeetCode-198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/result.jpg" class title="提交记录">

<hr>
<p>如有错误，欢迎联系本人QQ：965299766</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2.两数相加[链表]</title>
    <url>/2020/07/03/LeetCode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="##1. 题目描述"></a>##1. 题目描述</h2><p><em>标签：[链表][数学]</em></p>
<p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<a id="more"></a>

<p><strong>示例：</strong></p>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p>
<hr>
<h2 id="2-题解"><a href="#2-题解" class="headerlink" title="##2. 题解"></a>##2. 题解</h2><p>这道题是刷leetcode会遇到的第一道medium题，在很多公司面试时可能会遇到（不是我说的），考的是关于链表的知识，题目应该不算太难，偏向于基础题。</p>
<hr>
<p>首先看题目的输入输出，可以发现都是把一个数的各位的数字 逆序 插入到链表中，比如数字342，在本题中链表的表示形式就是2-&gt;4-&gt;3，这样做其实是降低了难度，因为我们平常做数字计算的时候，也是从低位到高位进行运算，运算产生的进位放到高位一起计算。<br>本题也是一样，由于输入的两个链表已经是对数字进行逆序处理了，我们只要按顺序从前往后将两个链表对应位置的数值加起来作为答案链表对应位置节点的数值即可，另外，需定义一个变量来保存计算产生的进位，计算时，带上进位一起计算。</p>
<hr>
<p>①. 定义变量<br>定义一个int变量，用以保存当前位运算产生的进位，默认为0，如有进位则置1，没有则置0；<br>定义了一个答案链表saveAns，在每次运算时将结果保存到该链表中，运算完毕，该链表就是结果链表；<br>但由于这是单向链表，在计算完成后，saveAns的指针指向的是答案的最后一位，为了可以返回答案链表的全部，需要另外设置一个链表变量realAns，默认作为指针指向答案的头结点，无论后面saveAns的指针怎么变，我最后只要返回realAns就行了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int addBit&#x3D;0;&#x2F;&#x2F;两数相加的进位，默认为0</span><br><span class="line">ListNode saveAns&#x3D;new ListNode(0);&#x2F;&#x2F;答案链表，用来保存每一步的答案</span><br><span class="line">ListNode realAns&#x3D;new ListNode(0);&#x2F;&#x2F;返回链表，用来返回最终答案</span><br><span class="line">realAns&#x3D;saveAns;&#x2F;&#x2F;一开始他们是相等的，理解为realAns作为指针指向了saveAns的头结点</span><br></pre></td></tr></table></figure>
<p>②. 循环计算<br>程序需要将两个数字链表对应位相加，显然需要使用循环，所以就要设置循环的条件：当两个加数的指针都为空且进位为0时，停止循环。<br>考虑到两个输入数可能位数不同，所以运算时，一个加数的指针处有值，而另一个加数的指针已经为空了，例如：一个加数是5-&gt;3-&gt;null，另一个是2-&gt;null，执行完5+2后，第一个加数的指针处为3，第二个加数指针处已经是null，所以遇到这种情况时，我们可以将那个null的值变成0进行运算。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;程序循环运行的条件：两个链表至少有一个不为空或者有进位不为0的时候</span><br><span class="line">		while(l1!&#x3D;null||l2!&#x3D;null||addBit!&#x3D;0) &#123;</span><br><span class="line">			saveAns.next&#x3D;new ListNode(0);&#x2F;&#x2F;创建一个节点，为计算做准备</span><br><span class="line">			saveAns&#x3D;saveAns.next;&#x2F;&#x2F;答案链表指针移动到下一节点</span><br><span class="line">			</span><br><span class="line">			int val1&#x3D;l1&#x3D;&#x3D;null?0:l1.val;</span><br><span class="line">			int val2&#x3D;l2&#x3D;&#x3D;null?0:l2.val;&#x2F;&#x2F;当前相加的两个数，在其对应链表中是否为空，为空则视为0进行运算，不为空则取出该数进行运算</span><br><span class="line">			int sum&#x3D;val1+val2+addBit;&#x2F;&#x2F;当前运算结果</span><br><span class="line">			saveAns.val&#x3D;sum%10;&#x2F;&#x2F;答案位（不带进位）</span><br><span class="line">			addBit&#x3D;sum&#x2F;10;&#x2F;&#x2F;进位</span><br><span class="line">			if(l1!&#x3D;null)&#x2F;&#x2F;因为如果此时l1为null，则他不存在l1.next，所以需要判断一下，不然会报NullPointerException的错</span><br><span class="line">				l1&#x3D;l1.next;</span><br><span class="line">			if(l2!&#x3D;null)</span><br><span class="line">				l2&#x3D;l2.next;&#x2F;&#x2F;两加数向后移动一位</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>③. 答案返回<br>计算过程可以发现，答案是从saveAns的第二位开始的，而realAns指向的是saveAns的第一位，所以需要返回realAns的next即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return realAns.next;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-完整代码"><a href="#3-完整代码" class="headerlink" title="##3. 完整代码"></a>##3. 完整代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ListNode&#123;</span><br><span class="line">	int val;</span><br><span class="line">	ListNode next;</span><br><span class="line">	ListNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line">	</span><br><span class="line">	public static  void print(ListNode l) &#123;&#x2F;&#x2F;自己加的，用来输出链表的各节点值</span><br><span class="line">		while(l!&#x3D;null) &#123;</span><br><span class="line">			System.out.println(l.val);</span><br><span class="line">			l&#x3D;l.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AddTwoNumbers &#123;</span><br><span class="line">	public static ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">		int addBit&#x3D;0;&#x2F;&#x2F;两数相加的进位，默认为0</span><br><span class="line">		ListNode saveAns&#x3D;new ListNode(0);&#x2F;&#x2F;答案链表，用来保存每一步的答案</span><br><span class="line">		ListNode realAns&#x3D;new ListNode(0);&#x2F;&#x2F;返回链表，用来返回最终答案</span><br><span class="line">		realAns&#x3D;saveAns;&#x2F;&#x2F;一开始他们是相等的，理解为realAns作为指针指向了saveAns的头结点</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;程序循环运行的条件：两个链表至少有一个不为空或者有进位不为0的时候</span><br><span class="line">		while(l1!&#x3D;null||l2!&#x3D;null||addBit!&#x3D;0) &#123;</span><br><span class="line">			saveAns.next&#x3D;new ListNode(0);&#x2F;&#x2F;创建一个节点，为计算做准备</span><br><span class="line">			saveAns&#x3D;saveAns.next;&#x2F;&#x2F;移动到下一节点</span><br><span class="line">			</span><br><span class="line">			int val1&#x3D;l1&#x3D;&#x3D;null?0:l1.val;</span><br><span class="line">			int val2&#x3D;l2&#x3D;&#x3D;null?0:l2.val;&#x2F;&#x2F;当前相加的两个数，在其对应链表中是否为空，为空则视为0进行运算</span><br><span class="line">			int sum&#x3D;val1+val2+addBit;&#x2F;&#x2F;当前运算结果</span><br><span class="line">			saveAns.val&#x3D;sum%10;&#x2F;&#x2F;答案位</span><br><span class="line">			addBit&#x3D;sum&#x2F;10;&#x2F;&#x2F;进位</span><br><span class="line">			if(l1!&#x3D;null)</span><br><span class="line">				l1&#x3D;l1.next;</span><br><span class="line">			if(l2!&#x3D;null)</span><br><span class="line">				l2&#x3D;l2.next;&#x2F;&#x2F;两加数向后移动一位</span><br><span class="line">		&#125;</span><br><span class="line">		return realAns.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;测试用例：l1&#x3D;2-&gt;4-&gt;3,l2&#x3D;5-&gt;6-&gt;4</span><br><span class="line">		ListNode l1&#x3D;new ListNode(2);</span><br><span class="line">		l1.next&#x3D;new ListNode(4);</span><br><span class="line">		l1.next.next&#x3D;new ListNode(3);</span><br><span class="line">		</span><br><span class="line">		ListNode l2&#x3D;new ListNode(5);</span><br><span class="line">		l2.next&#x3D;new ListNode(6);</span><br><span class="line">		l2.next.next&#x3D;new ListNode(4);</span><br><span class="line">		</span><br><span class="line">		ListNode.print(addTwoNumbers(l1, l2));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<img src="/2020/07/03/LeetCode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-%E9%93%BE%E8%A1%A8/run.jpg" class title="运行结果">
<p>答案正确。<br>leetcode提交记录：</p>
<img src="/2020/07/03/LeetCode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-%E9%93%BE%E8%A1%A8/result.jpg" class title="提交记录">

<p>如有错误，欢迎联系本人QQ：965299766</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 20.有效的括号[栈]</title>
    <url>/2020/07/04/LeetCode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7-%E6%A0%88/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="##1. 题目描述"></a>##1. 题目描述</h2><p><em>标签：[栈][字符串]</em><br>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<pre><code>左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。</code></pre><p>注意空字符串可被认为是有效字符串。</p>
<a id="more"></a>

<p><strong>示例 1:</strong></p>
<p>输入: “()”<br>输出: true</p>
<p><strong>示例 2:</strong></p>
<p>输入: “()[]{}”<br>输出: true</p>
<p><strong>示例 3:</strong></p>
<p>输入: “(]”<br>输出: false</p>
<p><strong>示例 4:</strong></p>
<p>输入: “([)]”<br>输出: false</p>
<p><strong>示例 5:</strong></p>
<p>输入: “{[]}”<br>输出: true</p>
<hr>
<h2 id="2-题解"><a href="#2-题解" class="headerlink" title="##2. 题解"></a>##2. 题解</h2><p>###2.1. 介绍<br>本题是一道简单题，但是如果单纯地使用字符串方法做，很难做出来，因为本题对字符串挨个研究时，还需要考虑整个字符串的结构，这是难以做到的，比如输入s=“([)]”，显然小括号和中括号在这里是可以被匹配到的，即每个左括号都对应一个右括号，但这个的结果是false，因为他整体不满足正确的闭合顺序。<br>针对这种情况，使用“栈”这种数据结构就能帮助我们掌握字符串的整体结构，从而容易地解决问题。</p>
<pre><code>在表示问题的递归结构时，栈数据结构可以派上用场。
我们无法真正地从内到外处理这个问题，因为我们对整体结构一无所知。
但是，栈可以帮助我们递归地处理这种情况，即从外部到内部。</code></pre><p>###2.2. 算法<br>①. 创建一个字符类型的栈stack，置为空；<br>②. 对于输入字符串s，挨个字符判断入栈；<br>③. 如果栈为空，则s的当前字符入栈，不进行任何判断；<br>④. 如果s的当前字符是右括号（右括号指 “)”,”]”或”}”），且栈不为空，则判断栈顶元素，如果是与当前字符匹配的左括号，这对匹配成功的括号抵消，表示为向栈中插入该字符，再把栈顶的两个元素删除，实际操作时可简化为不插入元素，只删除栈顶一个元素即可达到同样效果。<br>⑤. 如果插入的不是右括号，则直接入栈即可。<br>⑥. 最后判断栈是否为空，为空则表示所有括号全部匹配成功，都被抵消了，返回true；不为空则表示该字符串不符合题目要求，返回false。</p>
<p>###2.3. 完整程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Stack;</span><br><span class="line">public class IsValid &#123;</span><br><span class="line">	public boolean isValid(String s) &#123;</span><br><span class="line">        if(s.equals(&quot;&quot;))</span><br><span class="line">            return true;</span><br><span class="line">        else&#123;</span><br><span class="line">            Stack&lt;Character&gt; stack&#x3D;new Stack&lt;Character&gt;();&#x2F;&#x2F;字符类型的栈</span><br><span class="line">        	for(int i&#x3D;0;i&lt;s.length();i++) &#123;</span><br><span class="line">        		if(stack.isEmpty()) &#123;&#x2F;&#x2F;如果当前栈为空，直接插入，不执行下面的判断了</span><br><span class="line">        			stack.push(s.charAt(i));</span><br><span class="line">        			continue;</span><br><span class="line">        		&#125;</span><br><span class="line">        		if(s.charAt(i)&#x3D;&#x3D;&#39;)&#39;&amp;&amp;stack.peek()&#x3D;&#x3D;&#39;(&#39;)&#123;&#x2F;&#x2F;如果匹配成功，则这对括号同时抵消，即取出栈顶元素</span><br><span class="line">        			stack.pop();</span><br><span class="line">        		&#125;</span><br><span class="line">        		else if(s.charAt(i)&#x3D;&#x3D;&#39;]&#39;&amp;&amp;stack.peek()&#x3D;&#x3D;&#39;[&#39;) &#123;</span><br><span class="line">        			stack.pop();</span><br><span class="line">        		&#125;</span><br><span class="line">        		else if(s.charAt(i)&#x3D;&#x3D;&#39;&#125;&#39;&amp;&amp;stack.peek()&#x3D;&#x3D;&#39;&#123;&#39;) &#123;</span><br><span class="line">        			stack.pop();</span><br><span class="line">        		&#125;</span><br><span class="line">        		else &#123;&#x2F;&#x2F;如匹配失败，直接在栈中插入元素</span><br><span class="line">        			stack.push(s.charAt(i));</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        	if(stack.isEmpty())&#x2F;&#x2F;如果最后栈为空，表示括号全部匹配成功，抵消成功</span><br><span class="line">        		return true;</span><br><span class="line">        &#125;</span><br><span class="line">		return false;&#x2F;&#x2F;不然就返回false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String s&#x3D;&quot;[])&quot;;</span><br><span class="line">		IsValid i&#x3D;new IsValid();</span><br><span class="line">		System.out.println(i.isValid(s));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例：s=”[])”<br>测试结果：false</p>
<p>###2.4. LeetCode提交结果</p>
<img src="/2020/07/04/LeetCode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7-%E6%A0%88/result.jpg" class title="提交记录">

<hr>
<p>如有错误，欢迎联系本人QQ：965299766</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 200.岛屿数量[深度优先搜索]</title>
    <url>/2020/07/26/LeetCode-200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="##1. 题目描述"></a>##1. 题目描述</h2><p><em>标签：[深度优先搜索]</em></p>
<p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<a id="more"></a>

<p><strong>示例 1:</strong></p>
<p><strong>输入:</strong><br>[<br>[‘1’,’1’,’1’,’1’,’0’],<br>[‘1’,’1’,’0’,’1’,’0’],<br>[‘1’,’1’,’0’,’0’,’0’],<br>[‘0’,’0’,’0’,’0’,’0’]<br>]<br><strong>输出:</strong> 1</p>
<p><strong>示例 2:</strong></p>
<p><strong>输入:</strong><br>[<br>[‘1’,’1’,’0’,’0’,’0’],<br>[‘1’,’1’,’0’,’0’,’0’],<br>[‘0’,’0’,’1’,’0’,’0’],<br>[‘0’,’0’,’0’,’1’,’1’]<br>]<br>*<em>输出: *</em>3<br>*<em>解释: *</em>每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。</p>
<hr>
<h2 id="2-题解"><a href="#2-题解" class="headerlink" title="##2. 题解"></a>##2. 题解</h2><p><strong>2.1. 思路</strong><br>本题可以将数组看做一张图，对图进行遍历。</p>
<p><strong>当遍历到一个位置值为’1’的时候，即代表该点是岛屿的一个点，从该点开始，对图进行深度优先搜索，将所有搜索到的点都置为’0’，代表这些是属于同一个岛屿的点，搜索完毕时，计数器count+1；</strong><br>继续遍历，由于上次搜索，属于同一岛屿的点全部被置为’0’了，所以以后只会搜索到其他岛屿了，遍历结束，返回计数count。</p>
<p>我们也可以理解为<strong>“感染”</strong>的方式，即找到一个点为’1’时，对其周围的点递归进行<strong>“感染”</strong>，<strong>该点附近值同样为’1’的点被感染，值发生改变（可以置为不为’1’的任意值）</strong>，递归结束后，计数器count+1.</p>
<p><strong>2.2. 代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numIslands(char[][] grid) &#123;</span><br><span class="line">        int count &#x3D; 0;&#x2F;&#x2F;计数器</span><br><span class="line">        for(int i &#x3D; 0;i &lt; grid.length;i++)&#123;</span><br><span class="line">            for(int j &#x3D; 0;j &lt; grid[0].length;j++)&#123;&#x2F;&#x2F;遍历</span><br><span class="line">                if(grid[i][j] &#x3D;&#x3D; &#39;1&#39;)&#123;&#x2F;&#x2F;如果一个点是岛屿点</span><br><span class="line">                    infect(grid,i,j);&#x2F;&#x2F;从该点开始，进行感染</span><br><span class="line">                    count++;&#x2F;&#x2F;感染完一整个岛屿后，计数器+1</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void infect(char[][] grid,int i ,int j)&#123;</span><br><span class="line">        if(i &lt; 0 || i &gt;&#x3D; grid.length || j &lt; 0 || j &gt;&#x3D;grid[0].length || grid[i][j] !&#x3D; &#39;1&#39;)&#123;</span><br><span class="line">            return;&#x2F;&#x2F;如果被感染的点超出边界或其值不为&#39;1&#39;，即代表该点不是岛屿了，不能感染，直接返回</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j] &#x3D; &#39;2&#39;;&#x2F;&#x2F;将被感染的点置为非&#39;1&#39;值</span><br><span class="line">        infect(grid,i - 1,j);&#x2F;&#x2F;递归对该点周围四个点进行感染</span><br><span class="line">        infect(grid,i + 1,j);</span><br><span class="line">        infect(grid,i,j + 1);</span><br><span class="line">        infect(grid,i,j - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试用例：</strong><br>[<br>[‘1’,’1’,’1’,’1’,’0’],<br>[‘1’,’1’,’0’,’1’,’0’],<br>[‘1’,’1’,’0’,’0’,’0’],<br>[‘0’,’0’,’0’,’0’,’0’]<br>]</p>
<p><strong>测试结果：</strong>岛屿数量 = 1<br>结果正确。</p>
<p><strong>2.3. LeetCode提交记录</strong></p>
<img src="/2020/07/26/LeetCode-200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/result.jpg" class title="提交记录">

<hr>
<p>如有错误，欢迎联系本人QQ：965299766</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 21.合并两个有序链表[链表]</title>
    <url>/2020/07/05/LeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="##1. 题目描述"></a>##1. 题目描述</h2><p><em>标签：[链表]</em></p>
<p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<a id="more"></a>


<p><strong>示例：</strong></p>
<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
<hr>
<h2 id="2-题解"><a href="#2-题解" class="headerlink" title="##2. 题解"></a>##2. 题解</h2><p>这是一道简单题，在数据结构课程中也有讲过，由于输入的两个链表已经是有序链表了，我们只需要按顺序将两链表合并即可，思路如下：</p>
<p><strong>###2.1. 思路</strong><br>①. 创建一个答案链表ans用以保存答案；<br>②. 两个链表均从头开始比较，比较两链表对应位置的值，将较小的一方的值赋给ans，然后较小的一个链表指针向后移一位，同时ans的指针也后移一位，重复比较，直到一个链表指针为null；<br>③. 一个链表指针为null，将不为null那个链表赋值给ans即可。</p>
<p><strong>###2.2. 图解</strong><br>以l1=1-&gt;2-&gt;4,l2=1-&gt;3-&gt;4为例：</p>
<p>①. 两链表指针均从头开始。</p>
<img src="/2020/07/05/LeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-%E9%93%BE%E8%A1%A8/1.jpg" class title="图一">

<p>②. 两链表指针处的值进行比较，取较小值，发现都是1，相等，这时我们默认取l1的值，把l1的指针后移一位，把1赋给ans，并且ans后移一位（新建一个节点）。</p>
<img src="/2020/07/05/LeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-%E9%93%BE%E8%A1%A8/2.jpg" class title="图二">

<p>③. 两链表指针处均不为null，再次比较，发现l2的值为1小于l1的值2，将l2的值1赋给ans，l2和ans指针后移一位。</p>
<img src="/2020/07/05/LeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-%E9%93%BE%E8%A1%A8/3.jpg" class title="图三">

<p>④. 以此类推，直到有一个链表的指针指向了null，现在情形如图所示。</p>
<img src="/2020/07/05/LeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-%E9%93%BE%E8%A1%A8/4.jpg" class title="图四">

<p>⑤. 此时必有一个链表指针为null，一个链表指针不为null，我们只要将ans的指针连接到不为null的那个链表处即可。</p>
<img src="/2020/07/05/LeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-%E9%93%BE%E8%A1%A8/5.jpg" class title="图五">
<p>此时的ans链表就是我们要找的答案，返回他的头结点即可。</p>
<p><strong>###2.3. 完整代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ListNode &#123;</span><br><span class="line">	 int val;</span><br><span class="line">	 ListNode next;</span><br><span class="line">	 ListNode() &#123;&#125;</span><br><span class="line">	 ListNode(int val) &#123; this.val &#x3D; val; &#125;</span><br><span class="line">	 ListNode(int val, ListNode next) &#123; this.val &#x3D; val; this.next &#x3D; next; &#125;</span><br><span class="line">	 </span><br><span class="line">	 public void print(ListNode l) &#123;&#x2F;&#x2F;打印链表内容</span><br><span class="line">		 while(l!&#x3D;null) &#123;</span><br><span class="line">			 System.out.println(l.val);</span><br><span class="line">			 l&#x3D;l.next;</span><br><span class="line">		 &#125;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MergeTwoLists &#123;</span><br><span class="line">	public static ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;</span><br><span class="line">		ListNode ans&#x3D;new ListNode(0);</span><br><span class="line">		ListNode head&#x3D;ans;&#x2F;&#x2F;头结点，用来返回答案</span><br><span class="line">		while(l1!&#x3D;null&amp;&amp;l2!&#x3D;null) &#123;&#x2F;&#x2F;按顺序合并</span><br><span class="line">			ans.next&#x3D;new ListNode(0);</span><br><span class="line">			ans&#x3D;ans.next;</span><br><span class="line">			if(l1.val&gt;l2.val) &#123;</span><br><span class="line">				ans.val&#x3D;l2.val;</span><br><span class="line">				l2&#x3D;l2.next;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				ans.val&#x3D;l1.val;</span><br><span class="line">				l1&#x3D;l1.next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans.next&#x3D;new ListNode(0);</span><br><span class="line">		ans.next&#x3D;l1&#x3D;&#x3D;null?l2:l1;&#x2F;&#x2F;把ans连接到非空的那个链表上</span><br><span class="line">		return head.next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;测试用例：l1&#x3D;1-&gt;2-&gt;4,l2&#x3D;1-&gt;3-&gt;4</span><br><span class="line">		ListNode l1&#x3D;new ListNode(1);</span><br><span class="line">		l1.next&#x3D;new ListNode(2);</span><br><span class="line">		l1.next.next&#x3D;new ListNode(4);</span><br><span class="line">		</span><br><span class="line">		ListNode l2&#x3D;new ListNode(1);</span><br><span class="line">		l2.next&#x3D;new ListNode(3);</span><br><span class="line">		l2.next.next&#x3D;new ListNode(4);</span><br><span class="line">		</span><br><span class="line">		ListNode ans&#x3D;mergeTwoLists(l1,l2);</span><br><span class="line">		ans.print(ans);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例：l1=1-&gt;2-&gt;4;l2=1-&gt;3-&gt;4<br>测试结果：</p>
<img src="/2020/07/05/LeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-%E9%93%BE%E8%A1%A8/run.jpg" class title="运行结果">

<p>LeetCode提交记录：</p>
<img src="/2020/07/05/LeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-%E9%93%BE%E8%A1%A8/result.jpg" class title="提交记录">

<hr>
<p>如有错误，欢迎联系本人QQ：965299766</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3.无重复字符的最长子串[字符串]</title>
    <url>/2020/07/04/LeetCode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="##1. 题目描述"></a>##1. 题目描述</h2><p><em>标签：[字符串][哈希表][Sliding Window]</em></p>
<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<a id="more"></a>

<p><strong>示例 1:</strong></p>
<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
<p><strong>示例 2:</strong></p>
<p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p>
<p><strong>示例 3:</strong></p>
<p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
<hr>
<h2 id="2-我的做法"><a href="#2-我的做法" class="headerlink" title="##2. 我的做法"></a>##2. 我的做法</h2><p>###2.1. 我的思路<br>①. 输入一个字符串s，函数中创建一个StringBuilder sb（方便增删），在程序中动态地保存s的子串。还需要定义一个count（int），来保存每个子串的长度，最后取长度最大值作为答案输出。<br>②. 对字符串s一个字符一个字符进行判断，判断当前字符是否在sb中已出现。<br>③. 如果s当前位置的字符未在sb中出现（显然程序一开始sb是空，必定未出现），则sb中加上该字符，并且count+1.<br>//判断Stringbuilder s中是否存在字符c的函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static boolean isExist(StringBuilder s,char c) &#123;&#x2F;&#x2F;判断StringBuilder s中是否存在字符c</span><br><span class="line">		for(int i&#x3D;0;i&lt;s.length();i++) &#123;</span><br><span class="line">			if(c&#x3D;&#x3D;s.charAt(i))</span><br><span class="line">				return true;</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>④. 如果s当前位置的字符已在sb中出现，从头开始删除sb中的字符，直到遇见了那个重复的字符停止（重复的字符也要删除），举个例子：s=”wabcab”，某一时刻sb=”wabc”，s的下一个字符是a，显然在sb中已出现，则将sb从头开始删除，直到遇到那个相同的字符（a），同时那个相同的字符也要删除，即删除后sb=”bc”。count的值也要变成sb的长度，即count=2.<br>//从头开始删除StringBuilder s直到遇到字符c为止（c也要删除）的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static StringBuilder delete(StringBuilder s,char c) &#123;&#x2F;&#x2F;删除Stringbuilder中的字符直到出现第一个c为止（c也要删除）</span><br><span class="line">		int index&#x3D;0;</span><br><span class="line">		for(int i&#x3D;0;i&lt;s.length();i++) &#123;</span><br><span class="line">			if(s.charAt(i)&#x3D;&#x3D;c)</span><br><span class="line">				break;</span><br><span class="line">			else </span><br><span class="line">				index++;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;由于题目限制，s中必存在一个字符c，所以才能这样直接delete而不用考虑不存在字符c时会删除整个s的情况</span><br><span class="line">		return s.delete(0, index+1);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>⑤. 重复②直到s的每个字符都判断完成。<br>⑥. 最后输出在运行过程中count的最大值。</p>
<p>###2.2. 完整代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LengthOfLongestSubstring &#123;</span><br><span class="line">	public static boolean isExist(StringBuilder s,char c) &#123;&#x2F;&#x2F;判断StringBuilder s中是否存在字符c</span><br><span class="line">		for(int i&#x3D;0;i&lt;s.length();i++) &#123;</span><br><span class="line">			if(c&#x3D;&#x3D;s.charAt(i))</span><br><span class="line">				return true;</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static StringBuilder delete(StringBuilder s,char c) &#123;&#x2F;&#x2F;删除Stringbuilder中的字符直到出现第一个c为止（c也要删除）</span><br><span class="line">		int index&#x3D;0;</span><br><span class="line">		for(int i&#x3D;0;i&lt;s.length();i++) &#123;</span><br><span class="line">			if(s.charAt(i)&#x3D;&#x3D;c)</span><br><span class="line">				break;</span><br><span class="line">			else </span><br><span class="line">				index++;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;由于题目限制，s中必存在一个字符c，所以才能这样直接delete而不用考虑不存在字符c时会删除整个s的情况</span><br><span class="line">		return s.delete(0, index+1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">		StringBuilder sb&#x3D;new StringBuilder();</span><br><span class="line">		int count&#x3D;0;&#x2F;&#x2F;字符计数器</span><br><span class="line">		int ans&#x3D;0;&#x2F;&#x2F;答案</span><br><span class="line">		for(int i&#x3D;0;i&lt;s.length();i++) &#123;&#x2F;&#x2F;一个一个字符比较</span><br><span class="line">			if(isExist(sb,s.charAt(i))) &#123;&#x2F;&#x2F;如果存在相同的字符</span><br><span class="line">				ans&#x3D;count&gt;ans?count:ans;</span><br><span class="line">				sb&#x3D;delete(sb,s.charAt(i));</span><br><span class="line">				sb.append(s.charAt(i));</span><br><span class="line">				count&#x3D;sb.length();</span><br><span class="line">			&#125; else &#123;&#x2F;&#x2F;不存在相同字符</span><br><span class="line">				sb.append(s.charAt(i));</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		ans&#x3D;count&gt;ans?count:ans;&#x2F;&#x2F;获得最终答案</span><br><span class="line">		return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;测试用例：s&#x3D;&quot;pwwkew&quot;</span><br><span class="line">		String s&#x3D;&quot;pwwkew&quot;;</span><br><span class="line">		LengthOfLongestSubstring len&#x3D;new LengthOfLongestSubstring();</span><br><span class="line">		System.out.println(len.lengthOfLongestSubstring(s));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例：s=”pwwkew”<br>输出结果：3</p>
<p>###2.3. LeetCode提交结果</p>
<img src="/2020/07/04/LeetCode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-%E5%AD%97%E7%AC%A6%E4%B8%B2/result1.jpg" class title="提交记录">

<hr>
<h2 id="3-优化做法"><a href="#3-优化做法" class="headerlink" title="##3. 优化做法"></a>##3. 优化做法</h2><p>###3.1. 思路<br>由于在挨个字符的比较过程中，我们需要一直判断新的字符在当前子串中是否出现，我们就容易想到一种数据结构：哈希集合（Java中为HashSet）。<br>而由于题目要求的是子串（母串中的连续子字符串）而不是子序列（母串中的非连续子字符串），对于子串，我们可以考虑使用“滑动窗口”（Sliding Window）。<br>思路和我的想法差不多，举例字符串s=”pwwkew”，过程如下：</p>
<p>①. 首先挨个字符看，第一个字符显然是没重复的，放入集合中。</p>
<img src="/2020/07/04/LeetCode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-%E5%AD%97%E7%AC%A6%E4%B8%B2/1.jpg" class title="图一">

<p>②. 看第二个字符，很显然没重复，放入集合。</p>
<img src="/2020/07/04/LeetCode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.jpg" class title="图二">

<p>③. 再看第三个字符，是w，在集合中有重复。</p>
<img src="/2020/07/04/LeetCode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-%E5%AD%97%E7%AC%A6%E4%B8%B2/3.jpg" class title="图三">
<p>有重复怎么办，从左侧开始删除集合的内容，每删除一个字符，判断一次是否仍有重复。</p>
<p>④. 删掉第一个字符p，显然仍有重复。</p>
<img src="/2020/07/04/LeetCode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-%E5%AD%97%E7%AC%A6%E4%B8%B2/4.jpg" class title="图四">

<p>⑤. 删掉第二个字符w，显然此时没有重复了。</p>
<img src="/2020/07/04/LeetCode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-%E5%AD%97%E7%AC%A6%E4%B8%B2/5.jpg" class title="图五">

<p>⑥. 继续滑动窗口，将没有重复的k和e加入到集合。</p>
<img src="/2020/07/04/LeetCode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-%E5%AD%97%E7%AC%A6%E4%B8%B2/6.jpg" class title="图六">

<p>⑦. 加入w到集合中，发现有重复，从集合左侧开始删除元素。</p>
<img src="/2020/07/04/LeetCode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-%E5%AD%97%E7%AC%A6%E4%B8%B2/7.jpg" class title="图七">

<p>⑧. 删除第一个字符w，发现已经无重复。算法完成。</p>
<p>⑨. 最后将执行过程中出现的子串长度最大值输出作为结果。</p>
<hr>
<p>###3.2. 完整代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LengthOfLongestSubstring &#123;</span><br><span class="line">	public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">		Set&lt;Character&gt; sc&#x3D;new HashSet&lt;Character&gt;();</span><br><span class="line">		int n&#x3D;s.length();</span><br><span class="line">		&#x2F;&#x2F;右指针，默认为-1，代表未开始滑动</span><br><span class="line">		int right&#x3D;-1;</span><br><span class="line">		int ans&#x3D;0;&#x2F;&#x2F;答案</span><br><span class="line">		for(int i&#x3D;0;i&lt;n;i++) &#123;</span><br><span class="line">			if(i!&#x3D;0) &#123;&#x2F;&#x2F;如果存在字符重复，删除最左侧字符，第一次循环不删除</span><br><span class="line">				sc.remove(s.charAt(i-1));</span><br><span class="line">			&#125;</span><br><span class="line">				</span><br><span class="line">			while(right&lt;n-1&amp;&amp;!sc.contains(s.charAt(right+1))) &#123;&#x2F;&#x2F;当右指针未到达边界且不存在字符重复</span><br><span class="line">				sc.add(s.charAt(right+1));&#x2F;&#x2F;加入新字符</span><br><span class="line">				right++;&#x2F;&#x2F;右指针右移一位</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;获取现有所有子串的最大长度</span><br><span class="line">			ans &#x3D; Math.max(ans, right - i + 1);</span><br><span class="line">			&#125;</span><br><span class="line">		return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;测试用例：s&#x3D;&quot;pwwkew&quot;</span><br><span class="line">		String s&#x3D;&quot;pwwkew&quot;;</span><br><span class="line">		LengthOfLongestSubstring len&#x3D;new LengthOfLongestSubstring();</span><br><span class="line">		System.out.println(len.lengthOfLongestSubstring(s));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例：s=”pwwkew”<br>测试结果：3</p>
<p>###3.3. LeetCode提交结果</p>
<img src="/2020/07/04/LeetCode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-%E5%AD%97%E7%AC%A6%E4%B8%B2/result2.jpg" class title="提交记录">

<hr>
<p>如有错误欢迎联系QQ：965299766</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>字符串</tag>
        <tag>Sliding Window</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 309.最佳买卖股票时机含冷冻期[动态规划]</title>
    <url>/2020/07/10/LeetCode-309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="##1. 题目描述"></a>##1. 题目描述</h2><p><em>标签：[动态规划]</em></p>
<p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<pre><code>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</code></pre><a id="more"></a>

<p><strong>示例:</strong></p>
<p>输入: [1,2,3,0,2]<br>输出: 3<br>解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</p>
<hr>
<h2 id="2-题解"><a href="#2-题解" class="headerlink" title="##2. 题解"></a>##2. 题解</h2><p>我们由题目可以了解到：对于本题，我们每天的状态可分为三种：<br>①. 买入股票<br>②. 卖出股票<br>③. 冷冻期或不操作</p>
<p><strong>1. 我们首先定义动态规划数组</strong><br>当最后一次操作分别是：买入、卖出、冷冻期或不操作时，当日可获得的最大收益分别保存在数组buy、sell、cold中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[] buy&#x3D;new int[prices.length];	&#x2F;&#x2F;用以保存最后一次操作是买入的收益</span><br><span class="line">   int[] sell&#x3D;new int[prices.length];	&#x2F;&#x2F;用以保存最后一次操作是卖出的收益</span><br><span class="line">   int[] cold&#x3D;new int[prices.length];	&#x2F;&#x2F;用以保存最后一次操作是冷冻期的收益</span><br></pre></td></tr></table></figure>
<p><strong>2. 初始化数组</strong><br>当第一天是买入时，当天收益就是第一天股票价值的负数；<br>当第一天是卖出或冷冻期（不操作）时，收益就是0。即：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">buy[0]&#x3D;-prices[0];&#x2F;&#x2F;第一天就买入的话，收益是当天股票价格的负数</span><br><span class="line">sell[0]&#x3D;cold[0]&#x3D;0;&#x2F;&#x2F;第一天不能卖出或进入冷冻期，默认为0</span><br></pre></td></tr></table></figure>

<p>然后从第二天开始，获得递推公式：</p>
<pre><code>buy[i]=max(cold[i-1]-prices[i],buy[i-1]);
sell[i]=max(buy[i-1]+prices[i],sell[i-1]);
cold[i]=max(sell[i-1],cold[i-1]);
(i&gt;0时)</code></pre><p>解释：<br>①. 若最后一次操作是买入时，那只有两种情况：<br>    1）. 前一天是冷冻期，今天买入；<br>    2）. 前一天就是买入，今天就不操作。<br>②. 若最后一次操作是卖出时，那有两种情况：<br>    1）. 前一天是买入，今天卖出；<br>    2）. 前一天卖出，今天不操作（也就是冷冻期）。<br>③. 若最后一次操作是冷冻期，那有两种情况：<br>    1）. 前一天卖出，今天就是冷冻期；<br>    2）. 前一天就是冷冻期，今天不操作。</p>
<p><strong>3. 答案获取</strong><br>我们容易看出，如果最后一次操作是买入的话，那显然是亏钱的，因为这样收益还不如直接不买，啥也不干来的多。<br>所以我们最后从卖出数组sell和冷冻数组cold中获取最大收益。</p>
<hr>
<h2 id="3-完整代码"><a href="#3-完整代码" class="headerlink" title="##3. 完整代码"></a>##3. 完整代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MaxProfit &#123;</span><br><span class="line">    public static int maxProfit (int[] prices) &#123;</span><br><span class="line">    	if(prices.length&#x3D;&#x3D;0||prices.length&#x3D;&#x3D;1)</span><br><span class="line">    		return 0;&#x2F;&#x2F;价格数组长度为0或1时，利润直接返回0</span><br><span class="line">    	</span><br><span class="line">    	int[] buy&#x3D;new int[prices.length];	&#x2F;&#x2F;用以保存最后一次操作是买入的收益</span><br><span class="line">    	int[] sell&#x3D;new int[prices.length];	&#x2F;&#x2F;用以保存最后一次操作是卖出的收益</span><br><span class="line">    	int[] cold&#x3D;new int[prices.length];	&#x2F;&#x2F;用以保存最后一次操作是冷冻期的收益</span><br><span class="line">    	</span><br><span class="line">    	buy[0]&#x3D;-prices[0];&#x2F;&#x2F;第一天就买入的话，收益是当天股票价格的负数</span><br><span class="line">    	sell[0]&#x3D;cold[0]&#x3D;0;&#x2F;&#x2F;第一天不能卖出或进入冷冻期，默认为0</span><br><span class="line">    	</span><br><span class="line">    	for(int i&#x3D;1;i&lt;prices.length;i++) &#123;</span><br><span class="line">    		buy[i]&#x3D;Math.max(cold[i-1]-prices[i], buy[i-1]);&#x2F;&#x2F;只有两种情况：①.前一天是冷冻期，那今天买入；②.前一天已经买入，今天不操作</span><br><span class="line">    		sell[i]&#x3D;Math.max(buy[i-1]+prices[i], sell[i-1]);&#x2F;&#x2F;只有两种情况：①.前一天买入，今天卖出；②.前一天已经卖出，今天不操作（冷冻期）</span><br><span class="line">    		cold[i]&#x3D;Math.max(sell[i-1], cold[i-1]);	&#x2F;&#x2F;有两种情况：①.前一天卖出，今天就是冷冻期；②.前一天是冷冻期，今天不操作</span><br><span class="line">    	&#125;</span><br><span class="line">    	&#x2F;&#x2F;因为最后一次操作是买入的话必定亏钱，所以只要获得最后操作是卖出或冷冻期的最大收益即可</span><br><span class="line">		return Math.max(sell[prices.length-1], cold[prices.length-1]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;测试用例：股票价格为：&#123;1,2,3,0,2&#125;</span><br><span class="line">		int[] test &#x3D; new int[] &#123;1,2,3,0,2&#125;;</span><br><span class="line">		int ans&#x3D;maxProfit(test);</span><br><span class="line">		System.out.println(ans);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例：价格数组为：{1,2,3,0,2}<br>测试结果：最大收益：3<br>结果正确。</p>
<hr>
<p><strong>LeetCode提交记录</strong></p>
<img src="/2020/07/10/LeetCode-309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/result.jpg" class title="提交记录">

<p>如有错误，欢迎联系本人QQ：965299766</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 350.两个数组的交集II[排序][哈希表]</title>
    <url>/2020/07/13/LeetCode-350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II-%E6%8E%92%E5%BA%8F-%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="##1. 题目描述"></a>##1. 题目描述</h2><p><em>标签：[排序][哈希表]</em></p>
<p>给定两个数组，编写一个函数来计算它们的交集。</p>
<a id="more"></a>

<p><strong>示例 1:</strong></p>
<p>输入: nums1 = [1,2,2,1], nums2 = [2,2]<br>输出: [2,2]</p>
<p><strong>示例 2:</strong></p>
<p>输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>输出: [4,9]</p>
<p><strong>说明：</strong></p>
<pre><code>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。
我们可以不考虑输出结果的顺序。</code></pre><hr>
<h2 id="2-题解"><a href="#2-题解" class="headerlink" title="##2. 题解"></a>##2. 题解</h2><p><strong>###2.1. 解法一：挨个元素匹配法</strong><br>题目给定两数组nums1和nums2，我们选择nums1数组进行挨个元素匹配。<br>例如：nums1={1,2,2,1}，nums2={2,2}。<br>我们还需要一个答案数组ans来保存答案。</p>
<p>①. 先看nums1第一个元素，为1，在nums2中进行匹配，显然nums2中不存在1这个元素，匹配失败；</p>
<p>②. 再看nums1第二个元素，为2，在nums2中匹配成功，nums2中有2这个元素。匹配成功后，我们将2保存到ans数组，然后在nums2中删除2这个元素（nums2中有两个2，只要删除第一个2）；</p>
<p>③. 接着匹配nums1的第三个元素，为2，在nums1中进行匹配，此时的nums1由于删除了一个2，变成了{2}而非一开始的{2,2}。<br>我们进行匹配，2在nums2中依然存在，保存到ans数组，并在nums2中删掉这个2。此时的nums2变为{}，是空集；</p>
<p>④. 接着匹配nums1的第四个元素，而nums2已经为空，匹配必定失败。</p>
<p>⑤. nums1指针指到末尾了，匹配结束，此时ans数组就是我们要的答案，是这两个数组nums1和nums2的交集，返回他就行了。</p>
<p><strong>解法一的完整代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class Intersect &#123;</span><br><span class="line">	public static int[] intersect(int[] nums1, int[] nums2) &#123;</span><br><span class="line">		&#x2F;&#x2F;将int[]数组转换为ArrayList方便增删</span><br><span class="line">		ArrayList&lt;Integer&gt; array1&#x3D;new ArrayList&lt;Integer&gt;();</span><br><span class="line">		ArrayList&lt;Integer&gt; array2&#x3D;new ArrayList&lt;Integer&gt;();</span><br><span class="line">		ArrayList&lt;Integer&gt; ans&#x3D;new ArrayList&lt;Integer&gt;();&#x2F;&#x2F;保存答案的数组</span><br><span class="line">		for(int k:nums1)</span><br><span class="line">			array1.add(k);</span><br><span class="line">		for(int k:nums2)</span><br><span class="line">			array2.add(k);</span><br><span class="line">		</span><br><span class="line">		for(int k:array2) &#123;</span><br><span class="line">			if(array1.contains(k)) &#123;&#x2F;&#x2F;如果一个元素k在两数组中同时存在</span><br><span class="line">				ans.add(k);&#x2F;&#x2F;把该元素加到答案数组中去</span><br><span class="line">				array1.remove(getIndex(array1, k));&#x2F;&#x2F;从array1中删除该元素，防止重复匹配</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;将答案数组转化为题目要求输出的形式，即ArrayList转化为int[]</span><br><span class="line">		int[] answer&#x3D;new int[ans.size()];</span><br><span class="line">		for(int i&#x3D;0;i&lt;ans.size();i++)</span><br><span class="line">			answer[i]&#x3D;ans.get(i);</span><br><span class="line">		return answer;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	public static int getIndex(ArrayList&lt;Integer&gt; array,int goal) &#123;</span><br><span class="line">		&#x2F;&#x2F;获取目标值在array数组中的下标，如未找到返回-1</span><br><span class="line">		for(int i&#x3D;0;i&lt;array.size();i++) &#123;</span><br><span class="line">			if(array.get(i)&#x3D;&#x3D;goal)</span><br><span class="line">				return i;</span><br><span class="line">		&#125;</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;测试用例：nums1&#x3D; &#123;1,2,2,1&#125;,nums2&#x3D; &#123;2,2&#125;</span><br><span class="line">		int[] nums1&#x3D; &#123;1,2,2,1&#125;,nums2&#x3D; &#123;2,2&#125;;</span><br><span class="line">		int[] ans&#x3D;intersect(nums1, nums2);</span><br><span class="line">		for(int i&#x3D;0;i&lt;ans.length;i++)</span><br><span class="line">			System.out.println(ans[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例：nums1= {1,2,2,1},nums2= {2,2}<br>测试结果：{2,2}<br>结果正确。</p>
<hr>
<p><strong>LeetCode提交记录</strong></p>
<img src="/2020/07/13/LeetCode-350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II-%E6%8E%92%E5%BA%8F-%E5%93%88%E5%B8%8C%E8%A1%A8/result1.jpg" class title="提交记录">

<hr>
<p><strong>###2.2. 解法二：排序法</strong><br>我们换一个例子：nums1={1,2,4,2}，nums2={5,2,2}。<br>这次我们在一开始就将两数组按升序排序：</p>
<img src="/2020/07/13/LeetCode-350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II-%E6%8E%92%E5%BA%8F-%E5%93%88%E5%B8%8C%E8%A1%A8/1.jpg" class title="图一">
<p>两箭头代表对应的数组指针，从0开始。</p>
<p>①. 我们将两数组指针指向的值进行比较，比较结果与指针移动规则如下：<br><strong>1）两指针比较后，值较小的一方指针向后移一位；</strong><br><strong>2）如果值相等，将该值填入答案数组，两指针同时后移一位；</strong><br><strong>3）当至少一个指针到达末尾时结束。</strong><br>用该方法可以保证比较结束后，答案数组保存的就是两数组的交集。</p>
<p>②. 看本例，指针起始位置的两个值比较，nums1指针对应的值是1，小于nums2指针对应的值2，将nums1的指针后移一位：</p>
<img src="/2020/07/13/LeetCode-350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II-%E6%8E%92%E5%BA%8F-%E5%93%88%E5%B8%8C%E8%A1%A8/2.jpg" class title="图二">

<p>③. 再次比较，比较结果2=2，所以将2计入答案数组，两指针同时后移：</p>
<img src="/2020/07/13/LeetCode-350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II-%E6%8E%92%E5%BA%8F-%E5%93%88%E5%B8%8C%E8%A1%A8/3.jpg" class title="图三">

<p>④. 再次比较，发现结果2=2，再计入答案数组，两指针后移：</p>
<img src="/2020/07/13/LeetCode-350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II-%E6%8E%92%E5%BA%8F-%E5%93%88%E5%B8%8C%E8%A1%A8/4.jpg" class title="图四">

<p>⑤. 再次比较，发现4&lt;5，nums1指针向后移一位，发现移动后到达末尾，结束循环，输出答案数组作为答案即可。</p>
<img src="/2020/07/13/LeetCode-350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II-%E6%8E%92%E5%BA%8F-%E5%93%88%E5%B8%8C%E8%A1%A8/5.jpg" class title="图五">

<p><strong>解法二的完整代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Intersect2 &#123;</span><br><span class="line">	public static int[] intersect(int[] nums1, int[] nums2) &#123;</span><br><span class="line">		&#x2F;&#x2F;将两数组先升序排序</span><br><span class="line">		Arrays.sort(nums1);</span><br><span class="line">		Arrays.sort(nums2);</span><br><span class="line">		ArrayList&lt;Integer&gt; ans&#x3D;new ArrayList&lt;Integer&gt;();&#x2F;&#x2F;答案数组</span><br><span class="line">		</span><br><span class="line">		for(int i&#x3D;0,j&#x3D;0;i&lt;nums1.length&amp;&amp;j&lt;nums2.length;) &#123;</span><br><span class="line">			&#x2F;&#x2F;两个指针都从0开始，比较两指针的值，小的那一个数组指针+1，如果相等，保存答案的同时两指针均+1</span><br><span class="line">			if(nums1[i]&gt;nums2[j]) &#123;</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">			else if(nums1[i]&#x3D;&#x3D;nums2[j]) &#123;</span><br><span class="line">				ans.add(nums1[i]);</span><br><span class="line">				i++;j++;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;答案数组转化</span><br><span class="line">		int[] answer&#x3D;new int[ans.size()];</span><br><span class="line">		for(int i&#x3D;0;i&lt;ans.size();i++)</span><br><span class="line">			answer[i]&#x3D;ans.get(i);</span><br><span class="line">		return answer;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;测试用例：nums1&#x3D; &#123;1,2,2,1&#125;,nums2&#x3D; &#123;2,2&#125;</span><br><span class="line">			int[] nums1&#x3D; &#123;1,2,2,1&#125;,nums2&#x3D; &#123;2,2&#125;;</span><br><span class="line">			int[] ans&#x3D;intersect(nums1, nums2);</span><br><span class="line">			for(int i&#x3D;0;i&lt;ans.length;i++)</span><br><span class="line">				System.out.println(ans[i]);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例：nums1= {1,2,2,1},nums2= {2,2}<br>测试结果：{2,2}<br>结果正确。</p>
<hr>
<p><strong>LeetCode提交记录</strong></p>
<img src="/2020/07/13/LeetCode-350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II-%E6%8E%92%E5%BA%8F-%E5%93%88%E5%B8%8C%E8%A1%A8/result2.jpg" class title="提交记录">

<hr>
<p><strong>###2.3. 解法三：哈希表法</strong><br>还是那个例子：nums1={1,2,2,1}，nums2={2,2}。<br>我们创建一个HashMap来保存nums1中，各数及他出现的次数：</p>
<img src="/2020/07/13/LeetCode-350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II-%E6%8E%92%E5%BA%8F-%E5%93%88%E5%B8%8C%E8%A1%A8/6.jpg" class title="图六">

<p><strong>接下来很简单：比较nums2中的每个值是否在HashMap中作为key值存在，如果存在且对应的value（代表出现次数）大于0，我们就将该key值作为答案放入答案数组，同时该key对应的value值-1，代表已经成功匹配一次了，防止以后重复匹配。</strong></p>
<p>本题中nums2={2,2}，HashMap如图所示：</p>
<img src="/2020/07/13/LeetCode-350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II-%E6%8E%92%E5%BA%8F-%E5%93%88%E5%B8%8C%E8%A1%A8/7.jpg" class title="图七">
<p><strong>1）先匹配nums2中的第一个2，显然，在HashMap中作为key值存在，且目前value为2，大于0，所以，我们将2作为答案保存在答案数组，同时HashMap中2对应的value值-1变为1.</strong></p>
<p><strong>2）再匹配nums2中的第二个2，显然作为key值存在于HashMap，且目前value值为1，大于0，所以，我们再把这个2作为答案保存在答案数组中，同时HashMap中2对应的value值-1变为0.</strong></p>
<p><strong>3）重复以上步骤直到nums2匹配完成。返回答案数组即可。</strong></p>
<p><strong>解法三的完整代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class Intersect3 &#123;</span><br><span class="line">	public static int[] intersect(int[] nums1, int[] nums2) &#123;</span><br><span class="line">		Map&lt;Integer, Integer&gt; hash&#x3D;new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">		ArrayList&lt;Integer&gt; ans&#x3D;new ArrayList&lt;Integer&gt;();&#x2F;&#x2F;答案数组</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;初始化哈希表，将nums1中的各个值作为key，出现次数作为value</span><br><span class="line">		for(int k:nums1) &#123;</span><br><span class="line">			hash.put(k, 0);&#x2F;&#x2F;初始化阶段，我们先将各数值出现次数记为0次</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;开始计数，nums1的各个数每出现一次，对应的哈希表value值+1</span><br><span class="line">		for(int k:nums1) &#123;</span><br><span class="line">			int ls&#x3D;hash.get(k)+1;</span><br><span class="line">			hash.put(k, ls);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;开始匹配nums2的各个值</span><br><span class="line">		for(int k:nums2) &#123;</span><br><span class="line">			if(hash.containsKey(k)&amp;&amp;hash.get(k)&gt;0) &#123;&#x2F;&#x2F;如果nums2中的值在nums1中出现且在hash表中对应的value值，即出现次数大于0</span><br><span class="line">				ans.add(k);&#x2F;&#x2F;将他保存到答案数组</span><br><span class="line">				int ls&#x3D;hash.get(k)-1;</span><br><span class="line">				hash.put(k, ls);&#x2F;&#x2F;保存后hash表中对应key的value值-1</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;答案数组转化</span><br><span class="line">		int[] answer&#x3D;new int[ans.size()];</span><br><span class="line">		for(int i&#x3D;0;i&lt;ans.size();i++) &#123;</span><br><span class="line">			answer[i]&#x3D;ans.get(i);</span><br><span class="line">		&#125;</span><br><span class="line">		return answer;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;测试用例：nums1&#x3D; &#123;1,2,2,1&#125;,nums2&#x3D; &#123;2,2&#125;</span><br><span class="line">		int[] nums1&#x3D; &#123;1,2,2,1&#125;,nums2&#x3D; &#123;2,2&#125;;</span><br><span class="line">		int[] ans&#x3D;intersect(nums1, nums2);</span><br><span class="line">		for(int i&#x3D;0;i&lt;ans.length;i++)</span><br><span class="line">			System.out.println(ans[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例：nums1= {1,2,2,1},nums2= {2,2}<br>测试结果：{2,2}<br>结果正确。</p>
<hr>
<p><strong>LeetCode提交记录</strong></p>
<img src="/2020/07/13/LeetCode-350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II-%E6%8E%92%E5%BA%8F-%E5%93%88%E5%B8%8C%E8%A1%A8/result3.jpg" class title="提交记录">

<hr>
<p>如有错误，欢迎联系本人QQ：965299766</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 5.最长回文串[字符串][动态规划]</title>
    <url>/2020/07/10/LeetCode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<ul>
<li>字符串</li>
<li>动态规划</li>
</ul>
<hr>
<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="##1. 题目描述"></a>##1. 题目描述</h2><p><em>标签：[字符串][动态规划]</em></p>
<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<a id="more"></a>

<p><strong>示例 1：</strong></p>
<p>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。</p>
<p><strong>示例 2：</strong></p>
<p>输入: “cbbd”<br>输出: “bb”</p>
<hr>
<h2 id="2-题解"><a href="#2-题解" class="headerlink" title="##2. 题解"></a>##2. 题解</h2><p><strong>1. 暴力解法</strong><br>我们可以枚举所有可能的子串，分别判断是否是回文字符串，并保存最长子串的相关信息，输出最长子串。<br>做法是用两个指针不断枚举字符串的左右界，不断判断是否是回文串，详细不赘述。</p>
<p><strong>2. 动态规划方法</strong><br><strong>我们知道：当一个字符串（长度大于2）是回文字符串时，同时删除掉左右两端的字符，他仍然是回文串。<br>我们又知道：若一个字符串仅有一个字符，或者有两个字符且两字符相等时，这个字符串必是回文字符串。<br>所以，我们可以知道：若一个字符串已经是回文的了，在他两头加上两个相等的字符，他仍然是回文字符串。</strong><br>对此，我们可以使用动态规划方法解决。</p>
<p>①. 对于输入的给定字符串s，设置一个二维boolean类型的dp数组，dp[i][j]表示：字符串s从第i个字符开始，到第j个字符结束所表示的子串是否是回文的，true代表是回文，false代表不是；<br>②. dp初始化：我们知道仅有一个字符的子串必是回文字符串，我们将dp中代表仅有一个字符的位置置为true；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (int i &#x3D; 0 ; i &lt; len ; i++)</span><br><span class="line">	dp[i][i] &#x3D; true;</span><br></pre></td></tr></table></figure>
<p>③. 我们以字符串s=”babad”为例，此时dp数组如图：</p>
<img src="/2020/07/10/LeetCode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.jpg" class title="图1">

<p>④. 由前面的分析可得dp的递推公式：</p>
<pre><code>dp[i][j] = (s[i]==s[j]) and (|i-j&lt;3| or dp[i-1][j+1])</code></pre><p>由于dp[i][j]和dp[j][i]代表意思相同，我们只要将dp数组的左下或右上部分填满即可，不必重复考虑，这里，我们选择填满左下；</p>
<p>⑤. 按行优先填写，首先判断当前子串两头是否相等，然后判断子串长度是否小于3；<br>1）. 如果子串两头不相等，当前dp表格填false；<br>2）. 如果子串两头相等，且子串长度小于3，dp表格填true；<br>3）. 如果子串两头相等，且子串长度大于等于3，dp当前表格的值等于它右上角的值。<br>在填写过程中，我们必须选择合适的填写顺序，保证当前填写的dp的右上角有值。<br>填完dp数组如图所示：</p>
<img src="/2020/07/10/LeetCode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2.jpg" class title="图2">

<p>⑥. 在填写过程中，如果遇到dp为true的情况，记录当前子串的信息（起始位置和长度），并保留迄今为止最长子串的信息。最后返回他即可。</p>
<hr>
<h2 id="3-完整代码"><a href="#3-完整代码" class="headerlink" title="##3. 完整代码"></a>##3. 完整代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LongestPalindrome &#123;</span><br><span class="line">	public static String longestPalindrome(String s) &#123;</span><br><span class="line">		if (s &#x3D;&#x3D; null || s.length() &#x3D;&#x3D; 0 || s.length() &#x3D;&#x3D; 1)&#x2F;&#x2F;特殊情况处理</span><br><span class="line">			return s;</span><br><span class="line">		</span><br><span class="line">		int len &#x3D; s.length();&#x2F;&#x2F;字符串长度</span><br><span class="line">		int maxLength&#x3D;1,start&#x3D;0;&#x2F;&#x2F;记录回文子串的最大长度和起始位置</span><br><span class="line">		&#x2F;&#x2F;动态规划数组，dp[i][j]表示字符串第i个字符到第j个字符作为的子串是否为回文字符串</span><br><span class="line">		boolean[][] dp &#x3D; new boolean[len][len];</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;初始化，表示仅有一个字符的子串必是回文字符串</span><br><span class="line">		for (int i &#x3D; 0 ; i &lt; len ; i++)</span><br><span class="line">			dp[i][i] &#x3D; true;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;我们只需要填写二维数组dp左下的部分即可，因为dp[i][j]和dp[j][i]是一样的，无需重复考虑</span><br><span class="line">		for (int i &#x3D; 0 ; i &lt; len ; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0 ; j &lt; i ; j++) &#123;</span><br><span class="line">				</span><br><span class="line">				if (s.charAt(i) &#x3D;&#x3D; s.charAt(j)) &#123;&#x2F;&#x2F;如果两端字符相等</span><br><span class="line">					</span><br><span class="line">					if (i - j &lt; 3)</span><br><span class="line">						dp[i][j] &#x3D; true;&#x2F;&#x2F;如果子串长度小于3的话，无需进一步判断，它必定是回文的</span><br><span class="line">					else  &#123;&#x2F;&#x2F;如果子串长度大于等于3</span><br><span class="line">						dp[i][j]&#x3D;dp[i-1][j+1];</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">				else  &#123;</span><br><span class="line">					dp[i][j] &#x3D; false;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				&#x2F;&#x2F;如果当前记录的子串是回文的，且长度大于当前已记录的最长回文字符串长度</span><br><span class="line">				if (dp[i][j] &amp;&amp; i - j + 1 &gt; maxLength) &#123;</span><br><span class="line">					maxLength &#x3D; i - j + 1;</span><br><span class="line">					start &#x3D; j;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		return s.substring(start, start+maxLength);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;测试用例：String s&#x3D;&quot;babad&quot;</span><br><span class="line">		String s &#x3D; &quot;babad&quot;;</span><br><span class="line">		System.out.println(longestPalindrome(s));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例：字符串s=”babad”<br>测试结果：最长子串为：”bab”<br>结果正确。</p>
<p><strong>LeetCode提交记录</strong></p>
<img src="/2020/07/10/LeetCode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/result.jpg" class title="提交记录">

<p>如有错误，欢迎联系本人QQ：965299766</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 53.最大子序和[数组][动态规划]</title>
    <url>/2020/07/05/LeetCode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C-%E6%95%B0%E7%BB%84-%E5%88%86%E6%B2%BB%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="##1. 题目描述"></a>##1. 题目描述</h2><p><em>标签：[数组][动态规划]</em></p>
<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<a id="more"></a>

<p><strong>示例:</strong></p>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
<hr>
<h2 id="2-题解"><a href="#2-题解" class="headerlink" title="##2. 题解"></a>##2. 题解</h2><p><strong>###2.1. 动态规划算法</strong><br>题目要求一个有一个最大和的连续子数组，返回其最大和。<br>对于输入的数组nums，我们可以令：f(i)代表以第i的数作为子数组的结尾时的最大和，很显然，本题的答案就是所有f(i)中的最大值。<br>我们又可以发现，f(i)是和f(i-1)是相关的（i不等于0的时候），我们又能够得知，当i=0时，f(i)=nums[0]。所以，我们可以得出求f(i)的递推公式：</p>
<pre><code>f(i)=nums[0]，i=0时；
f(i)=max(f[i-1]+nums[i],nums[i])，0&lt;i&lt;=nums.length时.</code></pre><p>实际程序中，我们将f(i)抽象成数组，分别求出f(i)的值后，取其中最大值最为结果即可。<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MaxSubArray &#123;</span><br><span class="line">	public static int maxSubArray(int[] nums) &#123;</span><br><span class="line">		int save[]&#x3D;new int[nums.length];</span><br><span class="line">		save[0]&#x3D;nums[0];</span><br><span class="line">		</span><br><span class="line">		for(int i&#x3D;1;i&lt;nums.length;i++) &#123;</span><br><span class="line">			save[i]&#x3D;(save[i-1]+nums[i])&gt;nums[i]?(save[i-1]+nums[i]):nums[i];&#x2F;&#x2F;套用递推公式</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		int max&#x3D;Integer.MIN_VALUE;</span><br><span class="line">		for(int i&#x3D;0;i&lt;save.length;i++) &#123;&#x2F;&#x2F;求出save数组的最大值</span><br><span class="line">			if(save[i]&gt;max)</span><br><span class="line">				max&#x3D;save[i];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		return max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;测试用例：nums[]&#x3D;&#123;-2,1,-3,4,-1,2,1,-5,4&#125;</span><br><span class="line">		int nums[]&#x3D;new int[] &#123;-2,1,-3,4,-1,2,1,-5,4&#125;;</span><br><span class="line">		int ans&#x3D;maxSubArray(nums);</span><br><span class="line">		System.out.println(ans);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例：nums[]={-2,1,-3,4,-1,2,1,-5,4}<br>测试结果：6</p>
<hr>
<p>LeetCode提交记录：</p>
<img src="/2020/07/05/LeetCode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C-%E6%95%B0%E7%BB%84-%E5%88%86%E6%B2%BB%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/result1.jpg" class title="提交记录">


<hr>
<p><strong>###2.2. 小小的优化</strong><br>本题对f(i)创建数组的用途仅仅是用来求其中的最大值，针对本题，我们可以在套用公式求每个f(i)的时候同时求出最大值，这样就不用创建数组了。<br>程序如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MaxSubArray &#123;</span><br><span class="line">	public static int maxSubArray(int[] nums) &#123;</span><br><span class="line">		int ls&#x3D;nums[0];</span><br><span class="line">		int max&#x3D;ls;</span><br><span class="line">		</span><br><span class="line">		for(int i&#x3D;1;i&lt;nums.length;i++) &#123;</span><br><span class="line">			ls&#x3D;ls+nums[i]&gt;nums[i]?ls+nums[i]:nums[i];</span><br><span class="line">			max&#x3D;ls&gt;max?ls:max;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;测试用例：nums[]&#x3D;&#123;-2,1,-3,4,-1,2,1,-5,4&#125;</span><br><span class="line">		int nums[]&#x3D;new int[] &#123;-2,1,-3,4,-1,2,1,-5,4&#125;;</span><br><span class="line">		int ans&#x3D;maxSubArray(nums);</span><br><span class="line">		System.out.println(ans);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LeetCode提交记录：</p>
<img src="/2020/07/05/LeetCode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C-%E6%95%B0%E7%BB%84-%E5%88%86%E6%B2%BB%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/result2.jpg" class title="提交记录">
<p>时间消耗降低了。</p>
<h2 id="此外，本题还可以使用分治法解决。"><a href="#此外，本题还可以使用分治法解决。" class="headerlink" title="此外，本题还可以使用分治法解决。"></a>此外，本题还可以使用分治法解决。</h2><p>如有错误，欢迎联系本人QQ：965299766</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 647.回文子串[字符串][动态规划]</title>
    <url>/2020/07/11/LeetCode-647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="##1. 题目描述"></a>##1. 题目描述</h2><p><em>标签：[字符串][动态规划]</em></p>
<p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。</p>
<a id="more"></a>

<p><strong>示例 1:</strong></p>
<p>输入: “abc”<br>输出: 3<br>解释: 三个回文子串: “a”, “b”, “c”.</p>
<p><strong>示例 2:</strong></p>
<p>输入: “aaa”<br>输出: 6<br>说明: 6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”.</p>
<p><strong>注意:</strong></p>
<p>   输入的字符串长度不会超过1000。</p>
<hr>
<h2 id="2-题解"><a href="#2-题解" class="headerlink" title="##2. 题解"></a>##2. 题解</h2><p>这道题也是一道动态规划题，和第5题是重复的，只不过本题是求回文子串的个数，第5题求的是最长的回文子串，代码都是几乎一样的，连接在这：<br><a href="https://a965299766.github.io/2020/07/10/LeetCode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" target="_blank" rel="noopener">LeetCode 5.最长回文串[字符串][动态规划]</a></p>
<hr>
<h2 id="3-完整代码"><a href="#3-完整代码" class="headerlink" title="##3. 完整代码"></a>##3. 完整代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CountSubstrings &#123;</span><br><span class="line">	public static int countSubstrings(String s) &#123;</span><br><span class="line">		int len&#x3D;s.length();</span><br><span class="line">		if(len&lt;2)</span><br><span class="line">			return len;</span><br><span class="line">		</span><br><span class="line">		boolean[][] dp&#x3D;new boolean[len][len];</span><br><span class="line">		int count&#x3D;0;</span><br><span class="line">		</span><br><span class="line">		for(int i&#x3D;0;i&lt;len;i++) &#123;</span><br><span class="line">			dp[i][i]&#x3D;true;</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		for(int i&#x3D;0;i&lt;len;i++) &#123;</span><br><span class="line">			for(int j&#x3D;0;j&lt;i;j++) &#123;</span><br><span class="line">				</span><br><span class="line">				if(s.charAt(i)&#x3D;&#x3D;s.charAt(j)) &#123;</span><br><span class="line">					</span><br><span class="line">					if(i-j+1&lt;3) &#123;</span><br><span class="line">						dp[i][j]&#x3D;true;</span><br><span class="line">					&#125;else &#123;</span><br><span class="line">						dp[i][j]&#x3D;dp[i-1][j+1];</span><br><span class="line">					&#125;</span><br><span class="line">							</span><br><span class="line">					</span><br><span class="line">				&#125;else &#123;</span><br><span class="line">					dp[i][j]&#x3D;false;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				if(dp[i][j]&#x3D;&#x3D;true)</span><br><span class="line">					count++;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;测试用例：s&#x3D;&quot;aaa&quot;</span><br><span class="line">		String s&#x3D;&quot;aaa&quot;;</span><br><span class="line">		System.out.println(countSubstrings(s));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例：s=”aaa”<br>测试结果：回文子串个数：6<br>结果正确。</p>
<p><strong>LeetCode提交记录</strong></p>
<img src="/2020/07/11/LeetCode-647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/result.jpg" class title="提交记录">

<p>如有错误，欢迎联系本人QQ：965299766</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 70.爬楼梯[动态规划]</title>
    <url>/2020/07/05/LeetCode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="1-题目描述："><a href="#1-题目描述：" class="headerlink" title="##1. 题目描述："></a>##1. 题目描述：</h2><p><em>标签：[动态规划][递归]</em></p>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<a id="more"></a>

<p><strong>示例 1：</strong></p>
<p>输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶</li>
<li>2 阶</li>
</ol>
<p><strong>示例 2：</strong></p>
<p>输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶 + 1 阶</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
</ol>
<hr>
<h2 id="2-题解"><a href="#2-题解" class="headerlink" title="##2. 题解"></a>##2. 题解</h2><p><strong>###2.1. 动态规划</strong><br>本题是很经典的动态规划问题，也可以用递归的方法解决，感觉类似于斐波那契数列。<br>①. 如果只有一级台阶，显然只有一种方法，那就是跨一步；<br>②. 如果有两级台阶，显然有两种方法，跨一步或者跨两步；<br>③. 如果有三级台阶，我们就要分两种情况：<br>    第一种情况：最后一步是跨了一级台阶，那显然跨这一级台阶前，我们需要爬两级台阶，而此时，问题转化成了我们之前已解决的问题：如何爬两级台阶，由②得知，爬两级台阶有两种方法，所以我们如果爬了这两级台阶，只能再爬一级到达第三级台阶，所以这种情况我们有两种方法，那就是1+1+1或2+1；<br>    第二种情况：最后一步是跨了二级台阶，那显然跨这二级台阶之前，我们必须先爬一级台阶，而爬一级台阶只有一种方法，所以这种情况我们有一种方法，那就是1+2.<br>④. 对此我们可以推出跨n级台阶的地推公式f(n)：</p>
<pre><code>f(n)=n,n=0,1,2
f(n)=f(n-1)+f(n-2),n&gt;2</code></pre><p>我们将f(n)用数组表示，容易写出以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ClimbStairs &#123;</span><br><span class="line">	public static int climbStairs(int n) &#123;</span><br><span class="line">		if(n&#x3D;&#x3D;0)</span><br><span class="line">			return 0;</span><br><span class="line">		if(n&#x3D;&#x3D;1)</span><br><span class="line">			return 1;</span><br><span class="line">		</span><br><span class="line">		int[] dp&#x3D;new int[n+1];</span><br><span class="line">		dp[1]&#x3D;1;&#x2F;&#x2F;爬一级楼梯只有一种方法</span><br><span class="line">		dp[2]&#x3D;2;&#x2F;&#x2F;爬两级楼梯有两种方法</span><br><span class="line">		for(int i&#x3D;3;i&lt;n+1;i++) &#123;</span><br><span class="line">			dp[i]&#x3D;dp[i-1]+dp[i-2];</span><br><span class="line">		&#125;</span><br><span class="line">		return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;测试用例：n&#x3D;5,n&#x3D;10</span><br><span class="line">		System.out.println(climbStairs(5));</span><br><span class="line">		System.out.println(climbStairs(10));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例：<br>①. 台阶数为：5，方法数为：8<br>②. 台阶数为：10，方法数为：89</p>
<p>LeetCode提交记录：</p>
<img src="/2020/07/05/LeetCode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/result1.jpg" class title="提交记录">

<hr>
<p><strong>###2.2. 递归</strong><br>和求斐波那契数列一样，我们也可以用递归的方法求解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ClimbStairs &#123;</span><br><span class="line">	public static int climbStairs(int n) &#123;</span><br><span class="line">		if(n&#x3D;&#x3D;0)</span><br><span class="line">			return 0;</span><br><span class="line">		if(n&#x3D;&#x3D;1)</span><br><span class="line">			return 1;</span><br><span class="line">		if(n&#x3D;&#x3D;2)</span><br><span class="line">			return 2;</span><br><span class="line">		</span><br><span class="line">		return climbStairs(n-1)+climbStairs(n-2);&#x2F;&#x2F;递归</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;测试用例：n&#x3D;5,n&#x3D;10</span><br><span class="line">		System.out.println(climbStairs(5));</span><br><span class="line">		System.out.println(climbStairs(10));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>程序一样获得了正确的结果</strong></p>
<pre><code>好处是程序看上去简单了，但坏处是显然的：
递归时重复计算太多，导致时间复杂度太大，在LeetCode上会因为超时而提交失败。</code></pre><img src="/2020/07/05/LeetCode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/result2.jpg" class title="提交记录">

<hr>
<p>如有错误，欢迎联系本人QQ：965299766</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>hello world</title>
    <url>/2020/07/03/hello-world/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This is a test file.<br>YYY<br>BBB</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 03. 数组中重复的数字[数组]</title>
    <url>/2020/07/29/%E5%89%91%E6%8C%87-Offer-03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="##1. 题目描述"></a>##1. 题目描述</h2><p><em>标签：[数组]</em></p>
<p>找出数组中重复的数字。</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<a id="more"></a>

<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong><br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 </p>
<p><strong>限制：</strong></p>
<p>2 &lt;= n &lt;= 100000</p>
<hr>
<h2 id="2-一般做法"><a href="#2-一般做法" class="headerlink" title="##2. 一般做法"></a>##2. 一般做法</h2><p>这道题使用简单方法的话，我们很容易想到用<strong>HashMap</strong>来解决：</p>
<p>①. 遍历数组，将<strong>数组中的值和对应出现次数保存到HashMap中</strong>；</p>
<p>②. 每次执行①操作时都判断该值出现的次数，<strong>如果大于1，说明这个值已经不是第一次出现了</strong>，按照题意，直接返回他即可。</p>
<p><strong>具体代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findRepeatNumber(int[] nums) &#123;</span><br><span class="line">       HashMap&lt;Integer,Integer&gt; hash &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       for(int k : nums)&#123;&#x2F;&#x2F;遍历数组</span><br><span class="line">           Integer count &#x3D; hash.get(k);&#x2F;&#x2F;获取当前值在map中已经出现的次数，未出现则为null</span><br><span class="line">           count &#x3D; count &#x3D;&#x3D; null ? 1 : count + 1;&#x2F;&#x2F;如果未出现，次数置为1，如果已出现，次数+1</span><br><span class="line">           if(count &gt; 1)&#x2F;&#x2F;如果出现次数大于1次，说明重复出现了</span><br><span class="line">                return k;&#x2F;&#x2F;返回他</span><br><span class="line">           hash.put(k,count);&#x2F;&#x2F;否则在map中插入他</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例：[2,3,1,0,2,5,3]<br>测试结果：2<br>结果正确。</p>
<p><strong>LeetCode提交记录</strong></p>
<img src="/2020/07/29/%E5%89%91%E6%8C%87-Offer-03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97-%E6%95%B0%E7%BB%84/result0.jpg" class title="提交记录">

<hr>
<h2 id="3-高级做法"><a href="#3-高级做法" class="headerlink" title="##3. 高级做法"></a>##3. 高级做法</h2><p>上一种方法中，我们可以发现程序运行使用的时间还是比较大的，我们可以使用一种更为巧妙的做法（<em>来源于《剑指Offer 第2版》</em>）。</p>
<p>①. 由于长度为n的数组nums中的数字都<strong>处于 0~n-1 的范围中</strong>，所以，<strong>如果数组没有数字重复，那么排序数组后，数字i一定出现在下标为i的位置上</strong>；<br><strong>正是因为有了重复的数字，所以，有的位置会对应多个数字，而有的位置可能没有对应数字。</strong></p>
<p>②. 从头遍历数组，<strong>设当前下标为i，对应的数字为m</strong>，首先<strong>比较该数字m是否等于i，如果等于，则说明已经排到了正确的位置</strong>，接着遍历下一个数字；</p>
<p>③. <strong>如果m不等于i，则将m和数组中位置为m的数进行比较，</strong>即比较 <strong>m == nums[m]</strong>，如果等于，则成功找到一个重复的数字，返回他。</p>
<p>④. <strong>如果不等于，将nums[i]和nums[m]交换一下位置，再次比较此时的nums[i]是否等于i，</strong>也就是回到了②和③的步骤，直到找到了一个重复的数字为止。</p>
<hr>
<h2 id="4-图解"><a href="#4-图解" class="headerlink" title="##4. 图解"></a>##4. 图解</h2><p>以 nums[] = {2,3,1,0,2,5,3} 为例：</p>
<img src="/2020/07/29/%E5%89%91%E6%8C%87-Offer-03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97-%E6%95%B0%E7%BB%84/0.jpg" class title="nums数组">

<p>①. 从头遍历，此时下标i = 0，对应值m = 2，显然0 ！= 2。<br>此时我们比较m是否等于nums[m]，显然二者不等（2 ！= 1），我们就将这两个数字交换位置；</p>
<img src="/2020/07/29/%E5%89%91%E6%8C%87-Offer-03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97-%E6%95%B0%E7%BB%84/1.jpg" class title="交换前">
<img src="/2020/07/29/%E5%89%91%E6%8C%87-Offer-03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97-%E6%95%B0%E7%BB%84/2.jpg" class title="交换后">

<p>②. 执行①操作后，<strong>当前下标i = 0处的值发生了改变，我们再次对他进行判断，显然此时下标值i = 0和元素值m = 1仍然不等，</strong>我们执行和①同样的操作：<br>判断m是否等于nums[m]，若相等，返回m，若不等，交换二者位置再次判断；</p>
<img src="/2020/07/29/%E5%89%91%E6%8C%87-Offer-03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97-%E6%95%B0%E7%BB%84/3.jpg" class title="交换前">
<img src="/2020/07/29/%E5%89%91%E6%8C%87-Offer-03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97-%E6%95%B0%E7%BB%84/4.jpg" class title="交换后">

<p>③. <strong>下标和元素值仍然不等，再次进行同样的操作；</strong></p>
<img src="/2020/07/29/%E5%89%91%E6%8C%87-Offer-03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97-%E6%95%B0%E7%BB%84/5.jpg" class title="交换前">
<img src="/2020/07/29/%E5%89%91%E6%8C%87-Offer-03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97-%E6%95%B0%E7%BB%84/6.jpg" class title="交换后">

<p>④. <strong>此时下标值和元素值均相同了，都是0。我们就可以遍历下一个元素了，此时下标i = 1，对应元素值也是m = 1，直接遍历下一个元素，</strong>后面以此类推；</p>
<img src="/2020/07/29/%E5%89%91%E6%8C%87-Offer-03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97-%E6%95%B0%E7%BB%84/7.jpg" class title="下标和元素值相等">

<p>⑤. <strong>直到遍历到i = 4，m = 2的时候，此时i和m值又不相同了：</strong></p>
<img src="/2020/07/29/%E5%89%91%E6%8C%87-Offer-03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97-%E6%95%B0%E7%BB%84/8.jpg" class title="下标和元素值又不相同了">
<p><strong>判断m和nums[m]值是否相等：</strong></p>
<img src="/2020/07/29/%E5%89%91%E6%8C%87-Offer-03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97-%E6%95%B0%E7%BB%84/9.jpg" class title="二者值相等">
<p><strong>显然二者值相等，即m == nums[m] == 2，意味着找到了重复的元素，</strong>直接返回他作为答案即可。</p>
<p><strong>具体代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findRepeatNumber(int[] nums) &#123;</span><br><span class="line">       int len &#x3D; nums.length;</span><br><span class="line">       if(len &#x3D;&#x3D; 0)&#x2F;&#x2F;数组为空</span><br><span class="line">            return -1;</span><br><span class="line">        </span><br><span class="line">        for(int i &#x3D; 0;i &lt; len ;i++)&#123;&#x2F;&#x2F;遍历数组</span><br><span class="line">            if(nums[i] &#x3D;&#x3D; i)&#123;&#x2F;&#x2F;如果元素值等于下标值</span><br><span class="line">                continue;&#x2F;&#x2F;直接遍历下一个元素</span><br><span class="line">            &#125;else&#123;&#x2F;&#x2F;如果不等</span><br><span class="line">                if(nums[i] &#x3D;&#x3D; nums[nums[i]])&#x2F;&#x2F;是否重复出现</span><br><span class="line">                    return nums[i];&#x2F;&#x2F;重复出现，返回答案</span><br><span class="line"></span><br><span class="line">                int temp &#x3D; nums[i];&#x2F;&#x2F;交换二者位置</span><br><span class="line">                nums[i] &#x3D; nums[nums[i]];</span><br><span class="line">                nums[temp] &#x3D; temp;</span><br><span class="line">                i--;&#x2F;&#x2F;继续对该下标进行判断</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例：[2,3,1,0,2,5,3]<br>测试结果：2<br>结果正确。</p>
<p><strong>LeetCode提交记录</strong></p>
<img src="/2020/07/29/%E5%89%91%E6%8C%87-Offer-03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97-%E6%95%B0%E7%BB%84/result.jpg" class title="提交记录">

<hr>
<p>如有错误，欢迎联系本人QQ：965299766</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>大家好辣</title>
    <url>/2020/07/03/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>大家好辣，我是阿伟，<br>是南信大计软院的一个废物，<br>这是我的个人博客，<br>欢迎来玩辣。<br>插张图片</p>
<img src="/2020/07/03/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/1.jpg" class title="狗妈">

<hr>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>编译原理[9.1-9.15]</title>
    <url>/2020/09/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-9-1-9-15/</url>
    <content><![CDATA[<p><strong>这篇记录了我2020.9.1至2020.9.15日上的编译原理课的知识点。</strong><br><em>本文部分图片来源于 [编译原理].Alfred.V.Aho.扫描版（pdf）</em></p>
<a id="more"></a>

<hr>
<h2 id="1-一个语言处理系统"><a href="#1-一个语言处理系统" class="headerlink" title="##1. 一个语言处理系统"></a>##1. 一个语言处理系统</h2><img src="/2020/09/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-9-1-9-15/1.jpg" class title="一个语言处理系统">

<p>此处“<strong>可重定位机器代码</strong>”，指在编程中引用了现有文件中的方法或成员，生成的代码将会在引用的地方做一个标记，通过<strong>链接器/加载器</strong>，可以从库文件中将对应代码插入到程序对应位置处。</p>
<p>如在C语言中，我们通过<strong>include&lt;stdio.h&gt;</strong>来使用其中的<strong>printf()</strong>函数和<strong>scanf()</strong>函数。在写程序时，我们并没有去实现这两个函数，但程序依然能够运行。正是因为这些函数处于库文件中，我们引用他的时候就会按上一段说的方法执行。</p>
<hr>
<h2 id="2-一个编译器的结构"><a href="#2-一个编译器的结构" class="headerlink" title="##2. 一个编译器的结构"></a>##2. 一个编译器的结构</h2><p>我们把编译器看做一个黑盒子，它<strong>能够把源程序映射在语义上等价的目标程序</strong>（如C语言程序通过编译生成机器能够执行的汇编语言程序，该C语言程序和汇编程序在语义上是等价的）。</p>
<p>上述的映射过程（即编译的过程）由两部分组成：<strong>分析部分</strong>和<strong>综合部分</strong>。</p>
<p><strong>分析部分</strong>：把源程序分解成多个组成要素，并在这些要素上加上语法结构。经常称为编译器的<strong>前端（front end）</strong>。前端包括：<strong>词法分析器，语法分析，语义分析，中间代码生成器</strong>。</p>
<p><strong>综合部分</strong>：根据中间表示和符号表中的信息来构造用户期待的目标程序。称为编译器的<strong>后端（back end</strong>）。后端包括：<strong>机器无关代码优化器，代码生成器，机器相关代码优化器</strong>。</p>
<p>以后将一一介绍这些部分。</p>
<img src="/2020/09/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-9-1-9-15/2.jpg" class title="一个编译器的各个步骤">

<p>一个例子较为直观的看编译器翻译过程：</p>
<img src="/2020/09/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-9-1-9-15/4.jpg" class title="一个赋值语句的翻译">

<hr>
<h2 id="3-词法分析"><a href="#3-词法分析" class="headerlink" title="##3. 词法分析"></a>##3. 词法分析</h2><p>是编译器的第一个步骤。</p>
<p>词法分析器读入组成源程序的字符流，并将它们组织成有意义的<strong>词素的序列</strong>。对于每个词素，词法分析器产生<strong>词法单元</strong>，保存在<strong>符号表中</strong>。<br>*解释：符号表：是如下结构的表：</p>
<img src="/2020/09/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-9-1-9-15/3.jpg" class title="符号表结构">

<p>第一列表示<strong>词的名字</strong>，第二列是<strong>该词对应的真正值</strong>，第二列又称为“<strong>词素</strong>”，第一列和第二列加来<strong>合称为“词法单元”</strong>。</p>
<p>词共有5个种类：<br><strong>①. 关键字，</strong>如if、else、for等；<br><strong>②. 标识符，</strong>如int a = 4;中的 a；<br><strong>③. 操作符，</strong>如&lt;、&gt;、&lt;=、&gt;=这些运算符；<br><strong>④. 常数，</strong>如PI = 3.14159；<br><strong>⑤. 界符，</strong>如(、)、{、}、[、]这些分割界限的符号。</p>
<p>那么编译器如何知道每个词是属于什么种类的，并把对应的值（词素）写入符号表呢？<br>通过<strong>模式</strong>：<strong>模式</strong>描述了一个词法单元的词素可能具有的形式。</p>
<p>如分析一个词，是“for”，通过对应的模式得知他是个<strong>关键字</strong>，那编译器就对其使用<strong>关键字</strong>的分析方法，分析出其对应的词素（对于一个关键字，模式分析方法就是把组成他的所有字符，合起来作为其词素），计入符号表。</p>
<p>符号表的<strong>每一行称为一个“词法单元”</strong>。形式为：<br><strong>&lt;name， value&gt;</strong><br>如&lt;for， f,o,r&gt;、&lt;number， 5.2&gt;<br>（ASCII码表也是一种符号表）</p>
<p>顺带一提，符号表中保存的某些词素，保存的不一定是他的真实值，很多时候保存的是他的<strong>*真实值的地址</strong>，即“<strong>指针</strong>”。</p>
<hr>
<p>有时，词法分析器可以分为两个级联的处理阶段：<br>1）<strong>扫描阶段：</strong>完成一些不需要生成词法单元的简单处理，如删除注释和将多个连续的空白压缩成一个字符等；<br>2）<strong>词法分析阶段：</strong>处理扫描阶段的输出并生成词法单元。</p>
<hr>
<h2 id="4-正则表达式"><a href="#4-正则表达式" class="headerlink" title="##4. 正则表达式"></a>##4. 正则表达式</h2><p><strong>1. 串：某个字母表上的一个串（string）是该字母表中符号的一个有穷序列。</strong><br><strong>串s的长度我们记作|s|。</strong><br>如：s = banana，|s| = 6</p>
<p><strong>空串：是长度为0的串，记为ε</strong></p>
<p><strong>注意：ε是空串，他不是字符，他是字符串！！</strong><br>如，字符集E = {a, b, c, ε}是错误的，ε不是字符。<br>字符串集s = {a, aab, ε}是正确的。</p>
<hr>
<p><strong>2. 语言：是某个给定字母表上的一个任意的可数的串的集合。</strong><br><strong>根据定义，空集∅和仅包含空串的集合{ε} 都属于语言。</strong></p>
<hr>
<p><strong>3. 串的术语：</strong><br><strong>①. 串s的前缀（prefix）：从s的尾部删除0或多个符号后得到的串。</strong>如，ban、banana、ε是banana的前缀。</p>
<p><strong>②. 串s的后缀（suffix）：从s的开始处删除0或多个符号后得到的串。</strong>如nana、banana、ε是banana的后缀。</p>
<p><strong>③. 串s的子串（substring）：删除s的某个前缀和某个后缀之后得到的串。</strong>如bnana、nan、ε是banana的子串。</p>
<p><strong>④. 串s的真前缀、真后缀、真子串：分别是s的既不等于s，也不等于ε的前缀、后缀和子串。</strong></p>
<p><strong>⑤. 串s的子序列：从s中删除0或多个符号后得到的串，这些删除的字符可能并不相邻。</strong>如baan是banana的一个子序列。</p>
<hr>
<p><strong>4. 串的连接与指数运算</strong><br>x = dog， y = house<br>我们<strong>将 xy = doghouse 称为x和y的连接。</strong></p>
<p>可知：<strong>εs = sε = s</strong></p>
<p>还能定义<strong>串的指数运算</strong>（^为指数运算符）：定义s ^ 0 = ε， 并且对于i &gt; 0， s ^ i = s ^ (i - 1) * s， 可知：<br><strong>s ^ 1 = s, s ^ 2 = ss, s ^ 3 = sss</strong></p>
<hr>
<p><strong>5. 语言上的运算</strong><br>对于语言，我们也有运算方法：</p>
<p><strong>①. 并：</strong>L ∪ M = {s | s属于L或者s属于M}<br>如：L = {a, aa, ab, ε}, M = {a, c}<br>则L ∪ M = {a, aa, ab, c, ε}</p>
<p><strong>②. 连接：</strong>LM = {st | s属于L且 t属于M}<br>如：L = {a, aa, ab, ε}, M = {a, c}<br>则LM = {aa, aaa, aba, a, ac, aac, abc, c}</p>
<p><strong>③. 闭包：</strong>将语言L连接0次或多次后得到的串集合，记作L*<br>如：L = {a, b}<br>则L* = {ε, a, b, aa, ab, bb, aaa, ……}</p>
<p><strong>④. 正闭包：</strong>将语言L连接0次或多次后得到的串集合，记作L+<br>L+就是L*减去ε的情况。</p>
<hr>
<p><strong>6. 正则表达式的运算</strong><br>假定r和s是语言L(r)和L(s)的正则表达式。那么：<br>1）(r) | (s)是一个正则表达式，表示语言L(r) ∪ L(s)；<br>2）(r)(s)是一个正则表达式，表示语言L(r)L(s)；<br>3）(r)*是一个正则表达式，表示语言L（(r)）*；<br>4）(r)是一个正则表达式，表示语言L(r)。</p>
<p><strong>优先级：</strong><br>1）*有最高的优先级，是左结合的（从左往右算）。<br>2）连接有次高的优先级，左结合。<br>3）|的优先级最低，左结合。</p>
<p><strong>例题：</strong><br>E = {a, b}<br>1）<strong>a|b</strong>表示语言{<strong>a, b</strong>}。<br>2）<strong>(a|b)(a|b)</strong>表示语言{<strong>aa, ab, ba, bb</strong>}。<br>3）<strong>a*</strong>表示语言{<strong>ε, a, aa, aaa…</strong>}。<br>4）<strong>(a|b)*</strong>表示语言{<strong>ε, a, b, aa, ab, ba, bb, aaa, …</strong>}。</p>
<p><strong>*表示0个或多个出现。</strong><br><strong>+表示1个或多个出现。</strong></p>
<hr>
<h2 id="5-状态转换图"><a href="#5-状态转换图" class="headerlink" title="##5. 状态转换图"></a>##5. 状态转换图</h2><p><strong>状态转换图有一组称为“状态”的结点或圆圈。</strong><br><strong>状态图的边从图的一个状态指向另一个状态。</strong></p>
<p>词法分析时，通过状态转换图进行逐个字符判断，较为直观。</p>
<img src="/2020/09/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-9-1-9-15/5.jpg" class title="一个判断关键字he、she、his、hers的状态图">

<p>图中，数字加圈代表状态或结点，直线上标字母代表状态转移条件的边。<br>两个圈代表结束状态。</p>
<hr>
<p><strong>状态图转换为正则表达式</strong></p>
<img src="/2020/09/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-9-1-9-15/6.jpg" class title="状态转换图">

<p>将图中的分支化为或运算，循环化为闭包运算即可。</p>
<hr>
<h2 id="6-有穷自动机"><a href="#6-有穷自动机" class="headerlink" title="##6. 有穷自动机"></a>##6. 有穷自动机</h2><p><strong>本质上是和状态转换图类似的图。</strong></p>
<p><strong>有穷的含义：状态是有穷的。</strong></p>
<hr>
<p>###6.1. 不确定的有穷自动机</p>
<p>表达式：M = (S, Σ, δ, s0, F)<br>其中，<br><strong>S是有穷的状态集合。</strong><br><strong>Σ是一个串，即弧上的标注是串（包含ε）。</strong><br><strong>转换函数δ，他规定了一个状态S0，经过串e，转换为后继状态s1这个映射过程。</strong><br><strong>s0为状态图的开始状态。可以不止一个。</strong><br><strong>F是一个子集，代表一系列终止状态。</strong></p>
<p>不确定的有穷自动机与状态转换图十分类似，但是不确定的有穷自动机有如下特点：<br><strong>①. 同一个符号可以标记从同一状态出发到达多个目标状态的多条边。</strong><br><strong>②. 一条边的标号不仅可以是输入字母表中的字母符号或字符集合（即字符串），也可以是空符号串ε。</strong></p>
<img src="/2020/09/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-9-1-9-15/7.jpg" class title="一个不确定的有穷自动机">
<p>图中可以看到，结点0经过串a，状态可以转化为0，还可以转化为1，这是不确定的，所以他是不确定的有穷自动机。</p>
<hr>
<p>###6.2. 确定的有穷自动机</p>
<p>表达式：M = (S, Σ, δ, s0, F)</p>
<p>与确定的有穷自动机类似，不同的地方：<br><strong>①. DFA弧上的标号是字母，而NFA弧上的标号是串；</strong><br><strong>②. DFA起始结点只有一个，NFA起始结点是一个集合；</strong><br><strong>③. DFA从一个状态，经过某个有确定标注的弧后，可以到达唯一的一个后继状态。而NFA经过某个标注的弧后，可能会到达多个状态。</strong></p>
<p><strong>不确定的有穷自动机</strong>可以转化成<strong>确定的有穷自动机</strong>。</p>
<h2 id="7-不确定的有穷自动转化成确定的有穷自动机"><a href="#7-不确定的有穷自动转化成确定的有穷自动机" class="headerlink" title="##7. 不确定的有穷自动转化成确定的有穷自动机"></a>##7. 不确定的有穷自动转化成确定的有穷自动机</h2><p><strong>需要了解：ε闭包：</strong><br>对于不确定的有穷自动机，从某状态出发，经过ε的弧，能够到达所有状态的集合（包含该状态自己）。</p>
<img src="/2020/09/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-9-1-9-15/8.jpg" class title="一个不确定的有穷自动机">
<p>例如，本图的3结点，他的ε闭包就是{3, 2, 1, 0}。</p>
<hr>
<p><strong>从正则表达式到自动机</strong></p>
<hr>
<p>例题：<br>对于正则表达式 1(0|1)<em>101。<br>转化步骤：<br>*</em>①. 画出状态转换图**</p>
<img src="/2020/09/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-9-1-9-15/9.jpg" class title="状态转换图">

<p><strong>②. 列出状态转换矩阵</strong><br>2.1. 由于本题的正则表达式只有0和1组成，我们<strong>1） 从起点状态a开始，列出a经过0的弧能到达的状态集合（不包含状态a自己），和经过1的弧能到达的状态集合（不包含状态a自己）。</strong><br><strong>2.）求出状态集合后，对得到的两个集合分别求ε闭包，得到答案集合，填在对应的表格中。</strong></p>
<img src="/2020/09/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-9-1-9-15/10.jpg" class title="从起点出发">

<p>2.2. 然后将得到的两个后继状态集合作为当前的出发状态，再依次执行2.1所示步骤。</p>
<img src="/2020/09/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-9-1-9-15/11.jpg" class title="下一步">
<img src="/2020/09/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-9-1-9-15/12.jpg" class title="下一步">
<img src="/2020/09/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-9-1-9-15/13.jpg" class title="下一步">

<p><strong>直到没有新的状态集合出现，因为是有穷状态机，状态集合是有限的</strong>。</p>
<img src="/2020/09/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-9-1-9-15/14.jpg" class title="这步完成后没有新的状态出现">

<p>2.3. 将每种状态集合标记为新的状态：</p>
<img src="/2020/09/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-9-1-9-15/15.jpg" class title="标记出现的每种状态集合">

<p><strong>将每种状态集合用新的状态标记：</strong></p>
<img src="/2020/09/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-9-1-9-15/16.jpg" class title="将每种状态集合用新的状态标记">

<p><strong>③. 根据新的状态矩阵画出状态图</strong></p>
<img src="/2020/09/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-9-1-9-15/17.jpg" class title="转换后的确定的有穷自动机">
<p>*纠错：图中D状态应有一条 经过标号1的弧到达自身 的弧。</p>
<p><strong>④. 确定新状态机的终止状态</strong><br><em>新的状态机的终止态，就是包含原状态图机终止态的状态子集。</em></p>
<p>如本题，原状态机的终止态是结点g，那么新状态机中，只要包含g结点的新状态就是新的终止态，本题中新状态F包含旧状态g，那么F结点就是新状态机的终止态（图中未标注，应该给F结点画上双重圈）。</p>
<hr>
<h2 id="8-相关链接"><a href="#8-相关链接" class="headerlink" title="##8. 相关链接"></a>##8. 相关链接</h2><p><strong><a href="https://dulaogou.vip/2020/09/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-9-17/" target="_blank" rel="noopener">编译原理9.17-</a></strong></p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理[9.17-]</title>
    <url>/2020/09/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-9-17/</url>
    <content><![CDATA[<p><strong>接上文 <a href="https://dulaogou.vip/2020/09/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-9-1-9-15/" target="_blank" rel="noopener">编译原理9.1-9.15</a></strong></p>
<a id="more"></a>

<hr>
<h2 id="1-不确定有穷自动机（NFA）转化为确定有穷自动机（DFA）的一道例题"><a href="#1-不确定有穷自动机（NFA）转化为确定有穷自动机（DFA）的一道例题" class="headerlink" title="##1. 不确定有穷自动机（NFA）转化为确定有穷自动机（DFA）的一道例题"></a>##1. 不确定有穷自动机（NFA）转化为确定有穷自动机（DFA）的一道例题</h2><img src="/2020/09/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-9-17/1.jpg" class title="图1">
<img src="/2020/09/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-9-17/2.jpg" class title="图2">

<hr>
<h2 id="2-最小化一个DFA的状态数"><a href="#2-最小化一个DFA的状态数" class="headerlink" title="##2. 最小化一个DFA的状态数"></a>##2. 最小化一个DFA的状态数</h2><p>通过上面的算法，我们成功地将一个不确定的有穷自动机（NFA）转化为一个确定的有穷自动机（DFA），但这样的DFA是可能存在<strong>冗余</strong>的，即<br><strong>有两个或两个以上的状态，他们经过相同标号的弧到达的结点是相同的，即他们两个或多个状态结点，在功能上是完全相同的。</strong><br>这时，我们应该删除若干冗余结点，使得DFA的结点数尽可能的少，达到简化的效果。</p>
<p>如结点A通过字符1的弧，能够到达结点C，<br>结点B通过字符1的弧，也能够到达结点C，<br>此外，结点A和B没有其他的弧能到达其他结点，这时，我们认为结点A和B在功能上是一样的，我们应该删除其中一个，保留另一个。</p>
<hr>
<p>###2.1. 算法描述</p>
<p>算法的基本步骤是：<br>①. <strong>划分两个状态组：</strong>一组为<strong>终止态组成的集合</strong>（这里我们称为<strong>“接受状态组”</strong>），另一组为<strong>其他状态组成的集合</strong>（称为<strong>“非接受状态组”</strong>）。</p>
<p>②. <strong>选取非接受状态组A，并选定某个输入符号a，检查a是否能区分A组中的某些状态。</strong>即若A状态组中有一部分状态A1经过标号为a的弧，能够到达一组集合B，而A中另一部分状态A2经过标号为a的弧，能到达另外一组集合C。<strong>此时，我们把A1和A2从A中分割开。</strong></p>
<p>③. <strong>再选定某个输入符号b，重复②的分割过程，直到无法根据某个符号对一组状态进行分割为止。</strong>此时，原先的大状态组A被分割成了许多小的状态组A1,A2,A3……An，任意一个小的状态组中的所有状态，对于一个特定的输入符号，他们的行动都是一致的。</p>
<p>④. <strong>对于每个小的状态组，选取其中一个状态作为代表，删除组内其他的状态。</strong></p>
<p>⑤. <strong>如果有能够到达被删除状态的结点，将该结点连接至被删除状态结点的代表结点。</strong><br>如结点1通过字符a能到达结点3，结点2能通过字符a能到达结点4，经过上述算法，假设我们得出：结点3，4属于同一状态组，我们就要选出代表结点3，删除冗余结点4，那此时，结点2本来是指向4的，但是结点4被删除了，我们就把结点2指向结点4的代表结点3即可。</p>
<p><strong>此时，完成了简化算法</strong>。</p>
<hr>
<p>###2.2. 一道例题</p>
<img src="/2020/09/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-9-17/3.jpg" class title="图1">
<img src="/2020/09/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-9-17/4.jpg" class title="图2">
<img src="/2020/09/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-9-17/5.jpg" class title="图3">

<hr>
<h2 id="3-从正则表达式构造NFA"><a href="#3-从正则表达式构造NFA" class="headerlink" title="##3. 从正则表达式构造NFA"></a>##3. 从正则表达式构造NFA</h2><p>给出一个正则表达式，如何画出对应的状态图？</p>
<p>正则表达式的三种运算分别是<strong>连接运算A×B</strong>， <strong>或运算A|B</strong>， 闭包运算<strong>A*</strong>，分别转化为状态图为：</p>
<img src="/2020/09/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-9-17/6.jpg" class title="正则表达式转换为NFA">

<hr>
<h2 id="4-一道作业题"><a href="#4-一道作业题" class="headerlink" title="##4. 一道作业题"></a>##4. 一道作业题</h2><img src="/2020/09/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-9-17/7.jpg" class title="图1">
<img src="/2020/09/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-9-17/8.jpg" class title="图2">
<img src="/2020/09/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-9-17/9.jpg" class title="图3">

<hr>
<h2 id="5-相关链接"><a href="#5-相关链接" class="headerlink" title="##5. 相关链接"></a>##5. 相关链接</h2><p><strong><a href="https://dulaogou.vip/2020/09/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-9-1-9-15/" target="_blank" rel="noopener">编译原理9.1-9.15</a></strong></p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
</search>
